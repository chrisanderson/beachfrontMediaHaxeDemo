{
"version":3,
"file":"main.js",
"sourceRoot":"file:///",
"sources":["/usr/local/lib/haxe/std/DateTools.hx","/usr/local/lib/haxe/std/js/_std/EReg.hx","/usr/local/lib/haxe/std/js/_std/HxOverrides.hx","/usr/local/lib/haxe/std/Lambda.hx","/usr/local/lib/haxe/std/List.hx","/usr/local/lib/haxe/std/js/_std/Reflect.hx","/usr/local/lib/haxe/std/js/_std/Std.hx","/usr/local/lib/haxe/std/StringBuf.hx","/usr/local/lib/haxe/std/StringTools.hx","/usr/local/lib/haxe/std/js/_std/Type.hx","/Users/chrisanderson/development/haxe/beachfrontDemo/src/common/client/CommonModel.hx","/Users/chrisanderson/development/haxe/beachfrontDemo/src/common/client/Main.hx","/Users/chrisanderson/development/haxe/beachfrontDemo/src/common/client/settings/SettingsModel.hx","/Users/chrisanderson/development/haxe/beachfrontDemo/src/common/client/settings/SettingsService.hx","/Users/chrisanderson/development/haxe/haxelib/msignal/1,2,4/msignal/Signal.hx","/Users/chrisanderson/development/haxe/beachfrontDemo/src/common/client/signal/SettingsModelSignal.hx","/Users/chrisanderson/development/haxe/beachfrontDemo/src/common/client/signal/SettingsSignal.hx","/Users/chrisanderson/development/haxe/beachfrontDemo/src/common/client/util/BuildInfo.hx","/Users/chrisanderson/development/haxe/beachfrontDemo/src/common/client/util/LoaderService.hx","/usr/local/lib/haxe/std/haxe/Http.hx","/usr/local/lib/haxe/std/js/_std/haxe/ds/StringMap.hx","/usr/local/lib/haxe/std/haxe/rtti/Meta.hx","/usr/local/lib/haxe/std/js/Boot.hx","/usr/local/lib/haxe/std/js/Browser.hx","/Users/chrisanderson/development/haxe/beachfrontDemo/src/js/client/App.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/ClassMap.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/InjectionConfig.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/Injector.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/point/MethodInjectionPoint.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/point/ConstructorInjectionPoint.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/point/NoParamsConstructorInjectionPoint.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/point/PostConstructInjectionPoint.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/point/PropertyInjectionPoint.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/result/InjectionResult.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/result/InjectClassResult.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/result/InjectSingletonResult.hx","/Users/chrisanderson/development/haxe/haxelib/msignal/1,2,4/msignal/Slot.hx","/Users/chrisanderson/development/haxe/haxelib/msignal/1,2,4/msignal/SlotList.hx","/Users/chrisanderson/development/haxe/haxelib/tink_core/1,0,0-rc,12/src/tink/core/Error.hx","/usr/local/lib/haxe/std/js/_std/Math.hx","/Users/chrisanderson/development/haxe/haxelib/compiletime/2,6,0/src/CompileTime.hx","/usr/local/lib/haxe/std/haxe/Constraints.hx","/Users/chrisanderson/development/haxe/haxelib/minject/1,6,1/minject/point/InjectionPoint.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe DateTools class contains some extra functionalities for handling `Date`\n\tinstances and timestamps.\n\n\tIn the context of haxe dates, a timestamp is defined as the number of\n\tmilliseconds elapsed since 1st January 1970.\n**/\nclass DateTools {\n\n\t#if php\n\t#elseif (neko && !(macro || interp))\n\tstatic var date_format = neko.Lib.load(\"std\",\"date_format\",2);\n\t#else\n\tprivate static function __format_get( d : Date, e : String ) : String {\n\t\treturn switch( e ){\n\t\t\tcase \"%\":\n\t\t\t\t\"%\";\n\t\t\tcase \"C\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(Std.int(d.getFullYear()/100)),\"0\",2);\n\t\t\tcase \"d\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getDate()),\"0\",2);\n\t\t\tcase \"D\":\n\t\t\t\t__format(d,\"%m/%d/%y\");\n\t\t\tcase \"e\":\n\t\t\t\tuntyped Std.string(d.getDate());\n\t\t\tcase \"F\":\n\t\t\t\t__format(d,\"%Y-%m-%d\");\n\t\t\tcase \"H\",\"k\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getHours()),if( e == \"H\" ) \"0\" else \" \",2);\n\t\t\tcase \"I\",\"l\":\n\t\t\t\tvar hour = d.getHours()%12;\n\t\t\t\tuntyped StringTools.lpad(Std.string(hour == 0 ? 12 : hour),if( e == \"I\" ) \"0\" else \" \",2);\n\t\t\tcase \"m\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getMonth()+1),\"0\",2);\n\t\t\tcase \"M\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getMinutes()),\"0\",2);\n\t\t\tcase \"n\":\n\t\t\t\t\"\\n\";\n\t\t\tcase \"p\":\n\t\t\t\tuntyped if( d.getHours() > 11 ) \"PM\"; else \"AM\";\n\t\t\tcase \"r\":\n\t\t\t\t__format(d,\"%I:%M:%S %p\");\n\t\t\tcase \"R\":\n\t\t\t\t__format(d,\"%H:%M\");\n\t\t\tcase \"s\":\n\t\t\t\tStd.string(Std.int(d.getTime()/1000));\n\t\t\tcase \"S\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getSeconds()),\"0\",2);\n\t\t\tcase \"t\":\n\t\t\t\t\"\\t\";\n\t\t\tcase \"T\":\n\t\t\t\t__format(d,\"%H:%M:%S\");\n\t\t\tcase \"u\":\n\t\t\t\tuntyped{\n\t\t\t\t\tvar t = d.getDay();\n\t\t\t\t\tif( t == 0 ) \"7\"; else Std.string(t);\n\t\t\t\t}\n\t\t\tcase \"w\":\n\t\t\t\tuntyped Std.string(d.getDay());\n\t\t\tcase \"y\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getFullYear()%100),\"0\",2);\n\t\t\tcase \"Y\":\n\t\t\t\tuntyped Std.string(d.getFullYear());\n\t\t\tdefault:\n\t\t\t\tthrow \"Date.format %\"+e+\"- not implemented yet.\";\n\t\t}\n\t}\n\n\tprivate static function __format( d : Date, f : String ) : String {\n\t\tvar r = new StringBuf();\n\t\tvar p = 0;\n\t\twhile( true ){\n\t\t\tvar np = f.indexOf(\"%\", p);\n\t\t\tif( np < 0 )\n\t\t\t\tbreak;\n\n\t\t\tr.addSub(f,p,np-p);\n\t\t\tr.add( __format_get(d, f.substr(np+1,1) ) );\n\n\t\t\tp = np+2;\n\t\t}\n\t\tr.addSub(f,p,f.length-p);\n\t\treturn r.toString();\n\t}\n\t#end\n\n\t/**\n\t\tFormat the date `d` according to the format `f`. The format is\n\t\tcompatible with the `strftime` standard format, except that there is no\n\t\tsupport in Flash and JS for day and months names (due to lack of proper\n\t\tinternationalization API). On Haxe/Neko/Windows, some formats are not\n\t\tsupported.\n\t**/\n\tpublic static function format( d : Date, f : String ) : String {\n\t\t#if (neko && !(macro || interp))\n\t\t\treturn new String(untyped date_format(d.__t, f.__s));\n\t\t#elseif php\n\t\t\treturn untyped __call__(\"strftime\",f,d.__t);\n\t\t#else\n\t\t\treturn __format(d,f);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns the result of adding timestamp `t` to Date `d`.\n\n\t\tThis is a convenience function for calling\n\t\t`Date.fromTime(d.getTime() + t)`.\n\t**/\n\tpublic static inline function delta( d : Date, t : Float ) : Date {\n\t\treturn Date.fromTime( d.getTime() + t );\n\t}\n\n\tstatic var DAYS_OF_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n\t/**\n\t\tReturns the number of days in the month of Date `d`.\n\n\t\tThis method handles leap years.\n\t**/\n\tpublic static function getMonthDays( d : Date ) : Int {\n\t\tvar month = d.getMonth();\n\t\tvar year = d.getFullYear();\n\n\t\tif (month != 1)\n\t\t\treturn DAYS_OF_MONTH[month];\n\n\t\tvar isB = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n\t\treturn if (isB) 29 else 28;\n\t}\n\n\t/**\n\t\tConverts a number of seconds to a timestamp.\n\t**/\n\tpublic static inline function seconds( n : Float ) : Float {\n\t\treturn n * 1000.0;\n\t}\n\n\t/**\n\t\tConverts a number of minutes to a timestamp.\n\t**/\n\tpublic static inline function minutes( n : Float ) : Float {\n\t\treturn n * 60.0 * 1000.0;\n\t}\n\n\t/**\n\t\tConverts a number of hours to a timestamp.\n\t**/\n\tpublic static inline function hours( n : Float ) : Float {\n\t\treturn n * 60.0 * 60.0 * 1000.0;\n\t}\n\n\t/**\n\t\tConverts a number of days to a timestamp.\n\t**/\n\tpublic static inline function days( n : Float ) : Float {\n\t\treturn n * 24.0 * 60.0 * 60.0 * 1000.0;\n\t}\n\n\t/**\n\t\tSeparate a date-time into several components\n\t**/\n\tpublic static function parse( t : Float ) {\n\t\tvar s = t / 1000;\n\t\tvar m = s / 60;\n\t\tvar h = m / 60;\n\t\treturn {\n\t\t\tms : t % 1000,\n\t\t\tseconds : Std.int(s % 60),\n\t\t\tminutes : Std.int(m % 60),\n\t\t\thours : Std.int(h % 24),\n\t\t\tdays : Std.int(h / 24),\n\t\t};\n\t}\n\n\t/**\n\t\tBuild a date-time from several components\n\t**/\n\tpublic static function make( o : { ms : Float, seconds : Int, minutes : Int, hours : Int, days : Int } ) {\n\t\treturn o.ms + 1000.0 * (o.seconds + 60.0 * (o.minutes + 60.0 * (o.hours + 24.0 * o.days)));\n\t}\n\n\t#if (js || flash || php || cpp || python)\n\t/**\n\t\tRetrieve Unix timestamp value from Date components. Takes same argument sequence as the Date constructor.\n\t**/\n\tpublic static #if (js || flash || php) inline #end function makeUtc(year : Int, month : Int, day : Int, hour : Int, min : Int, sec : Int ):Float {\n\t    #if (js || flash || python)\n\t\t   return untyped Date.UTC(year, month, day, hour, min, sec);\n\t\t#elseif php\n\t\t   return untyped __call__(\"gmmktime\", hour, min, sec, month + 1, day, year) * 1000;\n\t\t#elseif cpp\n\t\t  return untyped __global__.__hxcpp_utc_date(year,month,day,hour,min,sec)*1000.0 ;\n\t\t#else\n\t\t\t//TODO\n\t\t   return 0.;\n\t\t#end\n\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : HaxeRegExp;\n\n\tpublic function new( r : String, opt : String ) : Void {\n\t\topt = opt.split(\"u\").join(\"\"); // 'u' (utf8) depends on page encoding\n\t\tthis.r = new HaxeRegExp(r, opt);\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n\n@:native(\"RegExp\")\nprivate extern class HaxeRegExp extends js.RegExp {\n\tvar m:js.RegExp.RegExpMatch;\n\tvar s:String;\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with 'using Lambda' and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass Lambda {\n\n\t/**\n\t\tCreates an Array from Iterable `it`.\n\n\t\tIf `it` is an Array, this function returns a copy of it.\n\t**/\n\tpublic static function array<A>( it : Iterable<A> ) : Array<A> {\n\t\tvar a = new Array<A>();\n\t\tfor(i in it)\n\t\t\ta.push(i);\n\t\treturn a;\n\t}\n\n\t/**\n\t\tCreates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.\n\t**/\n\tpublic static function list<A>( it : Iterable<A> ) : List<A> {\n\t\tvar l = new List<A>();\n\t\tfor(i in it)\n\t\t\tl.add(i);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tCreates a new List by applying function `f` to all elements of `it`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function map<A,B>( it : Iterable<A>, f : A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tfor( x in it )\n\t\t\tl.add(f(x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tSimilar to map, but also passes the index of each element to `f`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function mapi<A,B>( it : Iterable<A>, f : Int -> A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tvar i = 0;\n\t\tfor( x in it )\n\t\t\tl.add(f(i++,x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tTells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.\n\t**/\n\tpublic static function has<A>( it : Iterable<A>, elt : A ) : Bool {\n\t\tfor( x in it )\n\t\t\tif( x == elt )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function exists<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function foreach<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( !f(x) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tCalls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function iter<A>( it : Iterable<A>, f : A -> Void ) {\n\t\tfor( x in it )\n\t\t\tf(x);\n\t}\n\n\t/**\n\t\tReturns a List containing those elements of `it` for which `f` returned\n\t\ttrue.\n\n\t\tIf `it` is empty, the result is the empty List even if `f` is null.\n\n\t\tOtherwise if `f` is null, the result is unspecified.\n\t**/\n\tpublic static function filter<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tvar l = new List<A>();\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.\n\t**/\n\tpublic static function fold<A,B>( it : Iterable<A>, f : A -> B -> B, first : B ) : B {\n\t\tfor( x in it )\n\t\t\tfirst = f(x,first);\n\t\treturn first;\n\t}\n\n\t/**\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.\n\t**/\n\tpublic static function count<A>( it : Iterable<A>, ?pred : A -> Bool ) {\n\t\tvar n = 0;\n\t\tif( pred == null )\n\t\t\tfor( _ in it )\n\t\t\t\tn++;\n\t\telse\n\t\t\tfor( x in it )\n\t\t\t\tif( pred(x) )\n\t\t\t\t\tn++;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tTells if Iterable `it` does not contain any element.\n\t**/\n\tpublic static function empty<T>( it : Iterable<T> ) : Bool {\n\t\treturn !it.iterator().hasNext();\n\t}\n\n\t/**\n\t\tReturns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.\n\t**/\n\tpublic static function indexOf<T>( it : Iterable<T>, v : T ) : Int {\n\t\tvar i = 0;\n\t\tfor( v2 in it ) {\n\t\t\tif( v == v2 )\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function find<T>( it : Iterable<T>, f : T -> Bool ) : Null<T> {\n\t\tfor( v in it ) {\n\t\t\tif(f(v)) return v;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns a new List containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n\t**/\n\tpublic static function concat<T>( a : Iterable<T>, b : Iterable<T> ) : List<T> {\n\t\tvar l = new List();\n\t\tfor( x in a )\n\t\t\tl.add(x);\n\t\tfor( x in b )\n\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA linked-list of elements. The list is composed of two-elements arrays\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole array content every time.\n**/\nclass List<T> {\n\n\tprivate var h : Array<Dynamic>;\n\tprivate var q : Array<Dynamic>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default,null) : Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add( item : T ) {\n\t\tvar x:Array<Dynamic> = #if neko untyped __dollar__array(item,null) #else [item] #end;\n\t\tif( h == null )\n\t\t\th = x;\n\t\telse\n\t\t\tq[1] = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push( item : T ) {\n\t\tvar x : Array<Dynamic> = #if neko\n\t\t\tuntyped __dollar__array(item,h)\n\t\t#else\n\t\t\t[item,h]\n\t\t#end;\n\t\th = x;\n\t\tif( q == null )\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first() : Null<T> {\n\t\treturn if( h == null ) null else h[0];\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last() : Null<T> {\n\t\treturn if( q == null ) null else q[0];\n\t}\n\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop() : Null<T> {\n\t\tif( h == null )\n\t\t\treturn null;\n\t\tvar x = h[0];\n\t\th = h[1];\n\t\tif( h == null )\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty() : Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear() : Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove( v : T ) : Bool {\n\t\tvar prev = null;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( l[0] == v ) {\n\t\t\t\tif( prev == null )\n\t\t\t\t\th = l[1];\n\t\t\t\telse\n\t\t\t\t\tprev[1] = l[1];\n\t\t\t\tif( q == l )\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l[1];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic inline function iterator() : ListIterator<T> {\n\t\treturn new ListIterator<T>(h);\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l[0]));\n\t\t\tl = l[1];\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep : String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l[0]);\n\t\t\tl = l[1];\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter( f : T -> Bool ) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tif( f(v) )\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f : T -> X) : List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n\n}\n\nprivate class ListIterator<T> {\n\tvar head:Array<Dynamic>;\n\tvar val:Dynamic;\n\n\tpublic inline function new(head:Array<Dynamic>) {\n\t\tthis.head = head;\n\t\tthis.val = null;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn head != null;\n\t}\n\n\tpublic inline function next():T {\n\t\tval = head[0];\n\t\thead = head[1];\n\t\treturn val;\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic {\n\t\ttry return untyped o[field] catch( e : Dynamic ) return null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : haxe.Constraints.Function, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String;\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic inline function new() {\n\t\tb = \"\";\n\t}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t'using StringTools' and then acts as an extension to the String class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cpp\nusing cpp.NativeString;\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlEncode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLEncoder.encode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.EscapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.quote(s, \"\");\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlDecode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: htmlUnescape(htmlEscape(s)) == s\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is null, the result is unspecified.\n\n\t\tIf `start` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif cpp\n\t\tif (s.length<start.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str();\n\t\tvar p1 = start.c_str();\n\t\tfor(i in 0...start.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is null, the result is unspecified.\n\n\t\tIf `end` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif cpp\n\t\tif (s.length<end.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str().add( s.length-end.length );\n\t\tvar p1 = end.c_str();\n\t\tfor(i in 0...end.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String \"\", or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\t#if python\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length) return false;\n\t\t#end\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for ltrim(rtrim(s)).\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String \"\", `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String \"\", `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits length equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than String.charCodeAt() on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the \\0\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (untyped s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash || cpp)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif neko\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#elseif python\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static inline function getClass<T>( o : T ) : Class<T> {\n\t\treturn if (o == null) null else @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\tif (a == null)\n\t\t\treturn null;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f:Dynamic = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","package common.client;\n\nimport common.client.settings.SettingsModel;\nimport common.client.signal.SettingsModelSignal;\nimport common.client.util.BuildInfo;\n\n#if flash\nimport flash.errors.Error;\n#elseif js\nimport jQuery.*;\nimport js.Browser;\nimport js.Error;\n#end\n\n@:expose\nclass CommonModel\n{\n  @inject public var buildInfo:BuildInfo;\n  @inject public var settingsModel(default, never):SettingsModel;\n\n  public function new()\n  {\n    _init();\n  }\n\n  @post //this method is called automatically because of @post metadata\n  public function injectionsReady():Void\n  {\n    //#if (flash || js)\n    //var timeTimer = new Timer(1000);\n    //timeTimer.run = function()\n    //{\n    //  _currentDateTime = Date.now();\n    //\n    //  #if js\n    //  tempCurrentDateTime.text('[current date-time ${_currentDateTime.format(\"%m/%d/%Y %r\")}]');\n    //  #end\n    //}\n    //#end\n\n    //trace('buildInfo: $buildInfo');\n\n    settingsModel.settingsModelSignal.add(_onSettingsModelSignal);\n\n    var tempValue = 1;\n\n    trace(\"tempValue: \" + tempValue);\n\n    #if debug\n    //this increment doesn't occur in a release build\n    tempValue++;\n    #end\n\n    trace(\"tempValue: \" + tempValue);\n\n    tempValue++;\n\n    trace(\"tempValue: \" + tempValue);\n\n    #if js\n    var tempJsLog = new JQuery('#jsLog');\n\n    trace({'tempJsLog':tempJsLog});\n\n    tempJsLog.append('<br> BuildInfo.BUILD_TARGET: ${BuildInfo.BUILD_TARGET}');\n    tempJsLog.append('<br> BuildInfo.COMPILE_DATE_TIME_STRING: ${BuildInfo.COMPILE_DATE_TIME_STRING}');\n    tempJsLog.append('<br> BuildInfo.LAST_RUN_DATE_TIME_STRING: ${BuildInfo.LAST_RUN_DATE_TIME_STRING}');\n\n    //because we increment tempValue only in a debug build\n    //tempValue will be 3 for debug but 2 for release\n    tempJsLog.append('<br> tempValue: $tempValue');\n    #end\n\n    var tempErrorMessage = 'error message thrown for trace';\n    var tempError = null;\n\n    #if flash\n    tempError = new Error('${BuildInfo.COMPILE_TARGET}: $tempErrorMessage');\n    #elseif js\n    tempError = new Error('${BuildInfo.COMPILE_TARGET}: $tempErrorMessage');\n    #end\n\n    //does this still blow up flash?\n    try\n    {\n      trace('${BuildInfo.COMPILE_TARGET}: trace inside of a try catch statement might cause a meltdown in flash. without throw. in try block');\n    }\n    catch(error:Dynamic)\n    {\n      //this shouldn't be reachable but adding a trace to see if it can blow up flash anyway\n      trace('${BuildInfo.COMPILE_TARGET}: trace inside of a try catch statement might cause a meltdown in flash. with throw. in catch block');\n    }\n\n    try\n    {\n      trace('${BuildInfo.COMPILE_TARGET}: trace inside of a try catch statement might cause a meltdown in flash. with throw. in try block');\n\n      throw tempError;\n    }\n    catch(error:Dynamic)\n    {\n      trace('${BuildInfo.COMPILE_TARGET}: trace inside of a try catch statement might cause a meltdown in flash. with throw. in catch block');\n    }\n  }\n\n  private function _init():Void\n  {\n    trace('_init()');\n  }\n\n  private function _onSettingsModelSignal(eventType:String, value:SettingsModel):Void\n  {\n    if(eventType != SettingsModelSignal.MODEL_UPDATED){return;}\n\n    //settingsModel(default, never) means that\n    //settingsModel is readable here but not writable\n    //settingsModel = value;\n\n    //settingsModel.settingsVO is setup for read access only\n    //and won't compile we try to use write access\n    //settingsModel.settingsVO = null;\n\n    trace('settingsModel.settings.version: ${settingsModel.settings.version}');\n  }\n}","package common.client;\n\nimport common.client.signal.SettingsModelSignal;\nimport common.client.signal.SettingsSignal;\nimport common.client.util.BuildInfo;\nimport common.client.util.LoaderService;\nimport common.client.settings.*;\nimport minject.Injector;\n\n#if flash\nimport flash.Lib;\nimport flash.client.App;\nimport flash.display.Sprite;\nimport flash.events.Event;\n#elseif js\nimport js.client.App;\nimport js.Browser;\n#end\n\n#if js\n@:expose\n#end\n@:keep\nclass Main #if flash extends Sprite #end\n{\n  private var _mainInjector = new Injector();\n\n  #if flash\n  private var _app:App;\n  #elseif js\n  private var _app:App;\n  #end\n\n  public static function main()\n  {\n    trace('main()');\n\n    var mainInstance = new Main();\n  }\n\n  public function new()\n  {\n    #if flash\n    super();\n    #end\n\n    trace('new()');\n\n    _init();\n    _initInjector();\n  }\n\n  private function _init():Void\n  {\n    trace('_init()');\n\n    //setup flash embed as early as possible\n    var tempFlashVars = {};\n    var tempSwfParams =\n    {\n      menu:\"false\"\n      ,scale:\"noScale\"\n      ,allowFullscreen:\"true\"\n      ,allowScriptAccess:\"always\"\n      ,bgcolor:\"#eeeeee\"\n      ,wmode:\"direct\"\n      //,width:\"300\"\n      //,height:\"300\"\n    };\n\n    //these will trace to all targets (currently just flash and js)\n    trace({'tempFlashVars':tempFlashVars});\n    trace({'tempSwfParams':tempSwfParams});\n\n    //this only occurs when the js target is being compiled because of the compiler instructions #if js\n    //will blow up other targets like flash if the compiler instructions were not used\n    #if js\n    var tempSwfContainer = Browser.document.querySelector('#swfContainer');\n\n    trace({'tempSwfContainer':tempSwfContainer});\n\n    //if you don't want to wrap a library in a haxe extern you can use haxe magic to directly write to a target\n    //here i use __js__ to write raw js.  the untyped keyword tells haxe to not try to use any typing logic and to just accept the code as is\n    var tempSwfObject = untyped __js__('swfobject.embedSWF(\"swf/main.swf\", {0}, \"50%\", \"100%\", 10, null, {1}, {2})', tempSwfContainer, tempFlashVars, tempSwfParams);\n    #elseif flash\n    trace('stageWidth: ' + Lib.current.stage.stageWidth + ' stageHeight: ' + Lib.current.stage.stageHeight);\n\n    //give this sprite display content so we can add real dimensions\n    graphics.clear();\n    graphics.beginFill(0xff0000, 0);\n    graphics.drawRect(0, 0, Lib.current.stage.stageWidth, Lib.current.stage.stageHeight);\n    graphics.endFill();\n\n    width = Lib.current.stage.stageWidth;\n    height = Lib.current.stage.stageHeight;\n\n    trace('width: ' + width + ' height: ' + height);\n\n    Lib.current.stage.addChild(this);\n    Lib.current.stage.addEventListener(Event.ADDED_TO_STAGE, _onAddedToStage, false, 0, true);\n    #end\n  }\n\n  private function _initInjector():Void\n  {\n    trace('_initInjector()');\n\n    //_mainInjector.mapSingleton(Injector, 'main');//fix here thought about passing an instance of the _mainInjector around\n    _mainInjector.mapSingleton(BuildInfo);\n    _mainInjector.mapSingleton(CommonModel);\n    _mainInjector.mapSingleton(SettingsModel);\n    _mainInjector.mapSingleton(SettingsService);\n    _mainInjector.mapSingleton(SettingsSignal);\n    _mainInjector.mapSingleton(SettingsModelSignal);\n\n    _mainInjector.mapClass(LoaderService, LoaderService);\n\n    #if flash\n    //_app = new App();\n    //_mainInjector.injectInto(_app);\n\n    _app = _mainInjector.instantiate(App);\n\n    _initUI();//fix here this should be called in _onAddedToStage\n    #elseif js\n    //_app = new App();\n    //_mainInjector.injectInto(_app);\n\n    _app = _mainInjector.instantiate(App);\n\n    _initUI();\n    #end\n\n    //this these classes are intended to be used by both flash and js at the same time\n    //and can be instantiated outside the conditional compiler logic that's client side specific\n    _mainInjector.instantiate(CommonModel);\n  }\n\n  private function _initUI():Void\n  {\n    trace('_initUI()');\n\n    #if flash\n    addChild(_app);\n    #end\n  }\n\n  #if flash\n  private function _onAddedToStage(event:Event):Void\n  {\n    trace('_onAddedToStage()');\n\n    Lib.current.stage.removeEventListener(Event.ADDED_TO_STAGE, _onAddedToStage);\n\n    _initUI();\n  }\n  #end\n}","package common.client.settings;\n\nimport String;\nimport common.client.signal.SettingsSignal;\nimport common.client.signal.SettingsModelSignal;\n\n@:keep\nclass SettingsModel\n{\n  @inject public var settingsService(default, null):SettingsService;\n  @inject public var settingsSignal(default, null):SettingsSignal;\n  @inject public var settingsModelSignal(default, null):SettingsModelSignal;\n\n  public var settings(default, null):Settings;\n\n  public function new()\n  {\n  }\n\n  @post //this method is called automatically because of @post metadata\n  public function injectionsReady():Void\n  {\n    _init();\n  }\n\n  private function _init():Void\n  {\n    trace('_init()');\n\n    settingsSignal.add(_onSettingsSignal);\n\n    //settingsService.loadSettings('runtime/test.json');\n    //settingsService.loadSettings('runtime/testBroken.json');\n    //settingsService.loadSettings('nonExisting.json');\n  }\n\n  private function _onSettingsSignal(eventType:String, value:Settings):Void\n  {\n    if(eventType != SettingsSignal.LOAD_SUCCESS){return;}\n\n    settings = value;\n\n    //this will not compile because the Settings.version is typed as a String\n    //means we can define restrictive types for any dynamic data to help reduce errors\n    //settings.version = false;\n    //same here settings.data.id is typed as a String\n    //settings.data.id = false;\n\n    trace({'_onSettingsReady settings':settings});\n    trace({'_onSettingsReady settings.version':settings.version});\n    trace({'_onSettingsReady settings.data.settings.width':settings.data.settings.width});\n    trace({'_onSettingsReady settings.data.settings.height':settings.data.settings.height});\n\n    settingsModelSignal.dispatch(SettingsModelSignal.MODEL_UPDATED, this);\n  }\n}","package common.client.settings;\n\nimport common.client.signal.SettingsSignal;\nimport common.client.settings.Settings;\nimport common.client.util.LoaderService;\nimport haxe.Json;\n\nclass SettingsService\n{\n  @inject public var loaderService:LoaderService;\n  @inject public var settingsSignal:SettingsSignal;\n\n  private var _settings:Settings;\n\n  public function new()\n  {\n  }\n\n  @post //this method is called automatically because of @post metadata\n  public function injectionsReady():Void\n  {\n  }\n\n  public function loadSettings(url:String):Void\n  {\n    loaderService.loadFromUrl(url, _onSettingsLoadSuccess);\n\n    //return loaderService.loadFromUrl(url, function(result:String):Settings\n    //{\n    //  return _onSettingsLoadSuccess(result);\n    //});\n  }\n\n  private function _onSettingsLoadSuccess(result:String):Void\n  {\n    //trace({'_onSettingsLoadSuccess() result':result});\n\n    _settings = Json.parse(result);\n\n    //trace({'_onSettingsLoadSuccess() _settings':_settings});\n\n    settingsSignal.dispatch(SettingsSignal.LOAD_SUCCESS, _settings);\n  }\n}","/*\nCopyright (c) 2012 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage msignal;\n\nimport msignal.Slot;\n\n/**\n\tA convenience type describing any kind of signal.\n**/\ntypedef AnySignal = Signal<Dynamic, Dynamic>;\n\n/**\n\tA Signal manages a list of listeners, which are executed when the signal is \n\tdispatched.\n**/\n@:keepSub\nclass Signal<TSlot:Slot<Dynamic, Dynamic>, TListener>\n{\n\tpublic var valueClasses:Array<Dynamic>;\n\n\t/**\n\t\tThe current number of listeners for the signal.\n\t**/\n\tpublic var numListeners(get, null):Int;\n\t\n\tvar slots:SlotList<TSlot, TListener>;\n\tvar priorityBased:Bool;\n\n\tfunction new(?valueClasses:Array<Dynamic>)\n\t{\n\t\tif (valueClasses == null) valueClasses = [];\n\t\tthis.valueClasses = valueClasses;\n\t\tslots = cast SlotList.NIL;\n\t\tpriorityBased = false;\n\t}\n\n\t/**\n\t\tSubscribes a listener for the signal.\n\t\t\n\t\t@param listener A function matching the signature of TListener\n\t\t@return The added listener slot\n\t**/\n\tpublic function add(listener:TListener):TSlot\n\t{\n\t\treturn registerListener(listener);\n\t}\n\n\t/**\n\t\tSubscribes a one-time listener for this signal.\n\t\tThe signal will remove the listener automatically the first time it is called,\n\t\tafter the dispatch to all listeners is complete.\n\t\t\n\t\t@param listener A function matching the signature of TListener\n\t\t@return The added listener slot\n\t**/\n\tpublic function addOnce(listener:TListener):TSlot\n\t{\n\t\treturn registerListener(listener, true);\n\t}\n\n\t/**\n\t\tSubscribes a listener for the signal.\n\t\tAfter you successfully register an event listener,\n\t\tyou cannot change its priority through additional calls to add().\n\t\tTo change a listener's priority, you must first call remove().\n\t\tThen you can register the listener again with the new priority level.\n\t\t\n\t\t@param listener A function matching the signature of TListener\n\t\t@return The added listener slot\n\t**/\n\tpublic function addWithPriority(listener:TListener, ?priority:Int=0):TSlot\n\t{\n\t\treturn registerListener(listener, false, priority);\n\t}\n\n\t/**\n\t\tSubscribes a one-time listener for this signal.\n\t\tThe signal will remove the listener automatically the first time it is \n\t\tcalled, after the dispatch to all listeners is complete.\n\t\t\n\t\t@param listener A function matching the signature of TListener\n\t\t@return The added listener slot\n\t**/\n\tpublic function addOnceWithPriority(listener:TListener, ?priority:Int=0):TSlot\n\t{\n\t\treturn registerListener(listener, true, priority);\n\t}\n\n\t/**\n\t\tUnsubscribes a listener from the signal.\n\t\t\n\t\t@param listener The listener to remove\n\t\t@return The removed listener slot\n\t**/\n\tpublic function remove(listener:TListener):TSlot\n\t{\n\t\tvar slot = slots.find(listener);\n\t\tif (slot == null) return null;\n\t\t\n\t\tslots = slots.filterNot(listener);\n\t\treturn slot;\n\t}\n\n\t/**\n\t\tUnsubscribes all listeners from the signal.\n\t**/\n\tpublic function removeAll():Void\n\t{\n\t\tslots = cast SlotList.NIL;\n\t}\n\n\tfunction registerListener(listener:TListener, ?once:Bool=false, ?priority:Int=0):TSlot\n\t{\n\t\tif (registrationPossible(listener, once))\n\t\t{\n\t\t\tvar newSlot = createSlot(listener, once, priority);\n\t\t\t\n\t\t\tif (!priorityBased && priority != 0) priorityBased = true;\n\t\t\tif (!priorityBased && priority == 0) slots = slots.prepend(newSlot);\n\t\t\telse slots = slots.insertWithPriority(newSlot);\n\n\t\t\treturn newSlot;\n\t\t}\n\t\t\n\t\treturn slots.find(listener);\n\t}\n\n\tfunction registrationPossible(listener, once)\n\t{\n\t\tif (!slots.nonEmpty) return true;\n\t\t\n\t\tvar existingSlot = slots.find(listener);\n\t\tif (existingSlot == null) return true;\n\n\t\t#if debug\n\t\tif (existingSlot.once != once)\n\t\t{\n\t\t\t// If the listener was previously added, definitely don't add it again.\n\t\t\t// But throw an exception if their once values differ.\n\t\t\tthrow \"You cannot addOnce() then add() the same listener without removing the relationship first.\";\n\t\t}\n\t\t#end\n\t\t\n\t\treturn false; // Listener was already registered.\n\t}\n\n\tfunction createSlot(listener:TListener, ?once:Bool=false, ?priority:Int=0):TSlot\n\t{\n\t\treturn null;\n\t}\n\n\tfunction get_numListeners()\n\t{\n\t\treturn slots.length;\n\t}\n}\n\n/**\n\tSignal that executes listeners with no arguments.\n**/\nclass Signal0 extends Signal<Slot0, Void -> Void>\n{\n\tpublic function new()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t\tExecutes the signals listeners with no arguements.\n\t**/\n\tpublic function dispatch()\n\t{\n\t\tvar slotsToProcess = slots;\n\t\t\n\t\twhile (slotsToProcess.nonEmpty)\n\t\t{\n\t\t\tslotsToProcess.head.execute();\n\t\t\tslotsToProcess = slotsToProcess.tail;\n\t\t}\n\t}\n\n\toverride function createSlot(listener:Void -> Void, ?once:Bool=false, ?priority:Int=0)\n\t{\n\t\treturn new Slot0(this, listener, once, priority);\n\t}\n}\n\n/**\n\tSignal that executes listeners with one arguments.\n**/\nclass Signal1<TValue> extends Signal<Slot1<TValue>, TValue -> Void>\n{\n\tpublic function new(?type:Dynamic=null)\n\t{\n\t\tsuper([type]);\n\t}\n\n\t/**\n\t\tExecutes the signals listeners with one arguement.\n\t**/\n\tpublic function dispatch(value:TValue)\n\t{\n\t\tvar slotsToProcess = slots;\n\t\t\n\t\twhile (slotsToProcess.nonEmpty)\n\t\t{\n\t\t\tslotsToProcess.head.execute(value);\n\t\t\tslotsToProcess = slotsToProcess.tail;\n\t\t}\n\t}\n\n\toverride function createSlot(listener:TValue -> Void, ?once:Bool=false, ?priority:Int=0)\n\t{\n\t\treturn new Slot1<TValue>(this, listener, once, priority);\n\t}\n}\n\n/**\n\tSignal that executes listeners with two arguments.\n**/\nclass Signal2<TValue1, TValue2> extends Signal<Slot2<TValue1, TValue2>, TValue1 -> TValue2 -> Void>\n{\n\tpublic function new(?type1:Dynamic=null, ?type2:Dynamic=null)\n\t{\n\t\tsuper([type1, type2]);\n\t}\n\n\t/**\n\t\tExecutes the signals listeners with two arguements.\n\t**/\n\tpublic function dispatch(value1:TValue1, value2:TValue2)\n\t{\n\t\tvar slotsToProcess = slots;\n\t\t\n\t\twhile (slotsToProcess.nonEmpty)\n\t\t{\n\t\t\tslotsToProcess.head.execute(value1, value2);\n\t\t\tslotsToProcess = slotsToProcess.tail;\n\t\t}\n\t}\n\n\toverride function createSlot(listener:TValue1 -> TValue2 -> Void, ?once:Bool=false, ?priority:Int=0)\n\t{\n\t\treturn new Slot2<TValue1, TValue2>(this, listener, once, priority);\n\t}\n}\n","package common.client.signal;\n\nimport common.client.settings.SettingsModel;\nimport msignal.Signal.Signal2;\n\nclass SettingsModelSignal extends Signal2<String, SettingsModel>\n{\n  public static inline var MODEL_UPDATED:String = \"MODEL_UPDATED\";\n\n  public function new()\n  {\n    super();\n  }\n}","package common.client.signal;\n\nimport common.client.settings.Settings;\nimport msignal.Signal.Signal2;\n\nclass SettingsSignal extends Signal2<String, Settings>\n{\n  public static inline var LOAD_SUCCESS:String = \"LOAD_SUCCESS\";\n\n  public function new()\n  {\n    super();\n  }\n}","package common.client.util;\n\n@:keep //protect this class from being removed by dce == full\n@:expose\nclass BuildInfo\n{\n  public static var COMPILE_TARGET = 'unkown hinson';\n  public static var BUILD_TARGET = 'unkown hinson';\n  public static var COMPILE_DATE_TIME = CompileTime.buildDate();\n  public static var COMPILE_DATE_TIME_STRING = CompileTime.buildDate().toString();\n  public static var LAST_RUN_DATE_TIME_STRING = Date.now().toString();\n\n  //this is readonly because the second param null blocks write access\n  public var currentDateTime(default, null) = Date.now();\n  //using (get, set) means you can override the default behavior if needed\n  //@:isVar public var currentDateTime(get, set) = Date.now();//try this'n to see compiler complain about missing getter and setter\n\n  public function new()\n  {\n    _init();\n  }\n\n  private function _init():Void\n  {\n    #if js\n    COMPILE_TARGET = 'js';\n    #elseif flash\n    COMPILE_TARGET = 'flash';\n    #end\n\n    #if debug\n    BUILD_TARGET = 'debug';\n    #elseif !debug\n    BUILD_TARGET = 'release';\n    #end\n\n    trace('COMPILE_TARGET: $COMPILE_TARGET');\n    trace('BUILD_TARGET: $BUILD_TARGET');\n    trace('COMPILE_DATE_TIME_STRING: $COMPILE_DATE_TIME_STRING');\n    trace('LAST_RUN_DATE_TIME_STRING: $LAST_RUN_DATE_TIME_STRING');\n  }\n}","package common.client.util;\n\nimport haxe.Http;\nimport tink.core.Outcome;\nimport tink.core.Future;\n\n@:keep\nclass LoaderService\n{\n  public function new()\n  {\n    //\n  }\n\n  //public function loadFromUrl(url:String):Future<Outcome<String, String>>\n  //{\n  //  return Future.async(function(handler:Outcome<String, String>->Void){\n  //    var tempHandler:Http = new haxe.Http(url);\n  //\n  //    tempHandler.onData = function(data:String){\n  //      handler(Success(data));\n  //\n  //      trace('file loaded data: $data');\n  //    };\n  //    //tempHandler.onError = function(error:String) handler(Error(error));\n  //    tempHandler.request(false);\n  //  });\n  //}\n\n  public function loadFromUrl(url:String, ?onDataCallback:Dynamic, ?onErrorCallback:Dynamic):Void\n  {\n    var tempHttp:Http = new haxe.Http(url);\n\n    tempHttp.onData = (onDataCallback != null) ? onDataCallback : _onHttpData;\n    tempHttp.onError = (onErrorCallback != null) ? onErrorCallback : _onHttpError;\n    tempHttp.request(false);\n  }\n\n  private function _onHttpData(result:String):Void\n  {\n    trace('_onHttpData() result: $result');\n  }\n\n  private function _onHttpError(result:String):Void\n  {\n    trace('_onHttpError() result: $result');\n  }\n}","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n#if sys\n\nimport sys.net.Host;\nimport sys.net.Socket;\n\nprivate typedef AbstractSocket = {\n\tvar input(default,null) : haxe.io.Input;\n\tvar output(default,null) : haxe.io.Output;\n\tfunction connect( host : Host, port : Int ) : Void;\n\tfunction setTimeout( t : Float ) : Void;\n\tfunction write( str : String ) : Void;\n\tfunction close() : Void;\n\tfunction shutdown( read : Bool, write : Bool ) : Void;\n}\n\n#end\n\n/**\n\tThis class can be used to handle Http requests consistently across\n\tplatforms. There are two intended usages:\n\n\t- call haxe.Http.requestUrl(url) and receive the result as a String (not\n\tavailable on flash)\n\t- create a new haxe.Http(url), register your callbacks for onData, onError\n\tand onStatus, then call request().\n**/\nclass Http {\n\n\t/**\n\t\tThe url of `this` request. It is used only by the request() method and\n\t\tcan be changed in order to send the same request to different target\n\t\tUrls.\n\t**/\n\tpublic var url : String;\n\tpublic var responseData(default, null) : Null<String>;\n#if sys\n\tpublic var noShutdown : Bool;\n\tpublic var cnxTimeout : Float;\n\tpublic var responseHeaders : Map<String,String>;\n\tvar chunk_size : Null<Int>;\n\tvar chunk_buf : haxe.io.Bytes;\n\tvar file : { param : String, filename : String, io : haxe.io.Input, size : Int, mimeType : String };\n#elseif js\n\tpublic var async : Bool;\n#end\n\tvar postData : String;\n\tvar headers : List<{ header:String, value:String }>;\n\tvar params : List<{ param:String, value:String }>;\n\n\t#if sys\n\tpublic static var PROXY : { host : String, port : Int, auth : { user : String, pass : String } } = null;\n\t#end\n\n\t/**\n\t\tCreates a new Http instance with `url` as parameter.\n\n\t\tThis does not do a request until request() is called.\n\n\t\tIf `url` is null, the field url must be set to a value before making the\n\t\tcall to request(), or the result is unspecified.\n\n\t\t(Php) Https (SSL) connections are allowed only if the OpenSSL extension\n\t\tis enabled.\n\t**/\n\tpublic function new( url : String ) {\n\t\tthis.url = url;\n\t\theaders = new List<{ header:String, value:String }>();\n\t\tparams = new List<{ param:String, value:String }>();\n\n\t\t#if js\n\t\tasync = true;\n\t\t#elseif sys\n\t\tcnxTimeout = 10;\n\t\t#end\n\t\t#if php\n\t\tnoShutdown = ! untyped __call__('function_exists', 'stream_socket_shutdown');\n\t\t#end\n\t}\n\n\t/**\n\t\tSets the header identified as `header` to value `value`.\n\n\t\tIf `header` or `value` are null, the result is unspecified.\n\n\t\tThis method provides a fluent interface.\n\t**/\n\tpublic function setHeader( header : String, value : String ):Http {\n\t\theaders = Lambda.filter(headers, function(h) return h.header != header);\n\t\theaders.push({ header:header, value:value });\n\t\treturn this;\n\t}\n\n\tpublic function addHeader( header : String, value : String ):Http {\n\t\theaders.push({ header:header, value:value });\n\t\treturn this;\n\t}\n\n\t/**\n\t\tSets the parameter identified as `param` to value `value`.\n\n\t\tIf `header` or `value` are null, the result is unspecified.\n\n\t\tThis method provides a fluent interface.\n\t**/\n\tpublic function setParameter( param : String, value : String ):Http {\n\t\tparams = Lambda.filter(params, function(p) return p.param != param);\n\t\tparams.push({ param:param, value:value });\n\t\treturn this;\n\t}\n\n\tpublic function addParameter( param : String, value : String ):Http {\n\t\tparams.push({ param:param, value:value });\n\t\treturn this;\n\t}\n\n\t/**\n\t\tSets the post data of `this` Http request to `data`.\n\n\t\tThere can only be one post data per request. Subsequent calls overwrite\n\t\tthe previously set value.\n\n\t\tIf `data` is null, the post data is considered to be absent.\n\n\t\tThis method provides a fluent interface.\n\t**/\n\tpublic function setPostData( data : String ):Http {\n\t\tpostData = data;\n\t\treturn this;\n\t}\n\n\t#if (js || flash)\n\n\t#if js\n\tvar req:js.html.XMLHttpRequest;\n\t#elseif flash\n\tvar req:flash.net.URLLoader;\n\t#end\n\n\t/**\n\t\tCancels `this` Http request if `request` has been called and a response\n\t\thas not yet been received.\n\t**/\n\tpublic function cancel()\n\t{\n\t\tif (req == null) return;\n\t\t#if js\n\t\treq.abort();\n\t\t#elseif flash\n\t\treq.close();\n\t\t#end\n\t\treq = null;\n\t}\n\t#end\n\n\t/**\n\t\tSends `this` Http request to the Url specified by `this.url`.\n\n\t\tIf `post` is true, the request is sent as POST request, otherwise it is\n\t\tsent as GET request.\n\n\t\tDepending on the outcome of the request, this method calls the\n\t\tonStatus(), onError() or onData() callback functions.\n\n\t\tIf `this.url` is null, the result is unspecified.\n\n\t\tIf `this.url` is an invalid or inaccessible Url, the onError() callback\n\t\tfunction is called.\n\n\t\t(Js) If `this.async` is false, the callback functions are called before\n\t\tthis method returns.\n\t**/\n\tpublic function request( ?post : Bool ) : Void {\n\t\tvar me = this;\n\t#if js\n\t\tme.responseData = null;\n\t\tvar r = req = js.Browser.createXMLHttpRequest();\n\t\tvar onreadystatechange = function(_) {\n\t\t\tif( r.readyState != 4 )\n\t\t\t\treturn;\n\t\t\tvar s = try r.status catch( e : Dynamic ) null;\n\t\t\tif ( s != null ) {\n\t\t\t\t// If the request is local and we have data: assume a success (jQuery approach):\n\t\t\t\tvar protocol = js.Browser.location.protocol.toLowerCase();\n\t\t\t\tvar rlocalProtocol = ~/^(?:about|app|app-storage|.+-extension|file|res|widget):$/;\n\t\t\t\tvar isLocal = rlocalProtocol.match( protocol );\n\t\t\t\tif ( isLocal ) {\n\t\t\t\t\ts = r.responseText != null ? 200 : 404;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( s == untyped __js__(\"undefined\") )\n\t\t\t\ts = null;\n\t\t\tif( s != null )\n\t\t\t\tme.onStatus(s);\n\t\t\tif( s != null && s >= 200 && s < 400 ) {\n\t\t\t\tme.req = null;\n\t\t\t\tme.onData(me.responseData = r.responseText);\n\t\t\t}\n\t\t\telse if ( s == null ) {\n\t\t\t\tme.req = null;\n\t\t\t\tme.onError(\"Failed to connect or resolve host\");\n\t\t\t}\n\t\t\telse switch( s ) {\n\t\t\tcase 12029:\n\t\t\t\tme.req = null;\n\t\t\t\tme.onError(\"Failed to connect to host\");\n\t\t\tcase 12007:\n\t\t\t\tme.req = null;\n\t\t\t\tme.onError(\"Unknown host\");\n\t\t\tdefault:\n\t\t\t\tme.req = null;\n\t\t\t\tme.responseData = r.responseText;\n\t\t\t\tme.onError(\"Http Error #\"+r.status);\n\t\t\t}\n\t\t};\n\t\tif( async )\n\t\t\tr.onreadystatechange = onreadystatechange;\n\t\tvar uri = postData;\n\t\tif( uri != null )\n\t\t\tpost = true;\n\t\telse for( p in params ) {\n\t\t\tif( uri == null )\n\t\t\t\turi = \"\";\n\t\t\telse\n\t\t\t\turi += \"&\";\n\t\t\turi += StringTools.urlEncode(p.param)+\"=\"+StringTools.urlEncode(p.value);\n\t\t}\n\t\ttry {\n\t\t\tif( post )\n\t\t\t\tr.open(\"POST\",url,async);\n\t\t\telse if( uri != null ) {\n\t\t\t\tvar question = url.split(\"?\").length <= 1;\n\t\t\t\tr.open(\"GET\",url+(if( question ) \"?\" else \"&\")+uri,async);\n\t\t\t\turi = null;\n\t\t\t} else\n\t\t\t\tr.open(\"GET\",url,async);\n\t\t} catch( e : Dynamic ) {\n\t\t\tme.req = null;\n\t\t\tonError(e.toString());\n\t\t\treturn;\n\t\t}\n\t\tif( !Lambda.exists(headers, function(h) return h.header == \"Content-Type\") && post && postData == null )\n\t\t\tr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\n\n\t\tfor( h in headers )\n\t\t\tr.setRequestHeader(h.header,h.value);\n\t\tr.send(uri);\n\t\tif( !async )\n\t\t\tonreadystatechange(null);\n\t#elseif flash\n\t\tme.responseData = null;\n\t\tvar loader = req = new flash.net.URLLoader();\n\t\tloader.addEventListener( \"complete\", function(e) {\n\t\t\tme.req = null;\n\t\t\tme.responseData = loader.data;\n\t\t\tme.onData( loader.data );\n\t\t});\n\t\tloader.addEventListener( \"httpStatus\", function(e:flash.events.HTTPStatusEvent){\n\t\t\t// on Firefox 1.5, Flash calls onHTTPStatus with 0 (!??)\n\t\t\tif( e.status != 0 )\n\t\t\t\tme.onStatus( e.status );\n\t\t});\n\t\tloader.addEventListener( \"ioError\", function(e:flash.events.IOErrorEvent){\n\t\t\tme.req = null;\n\t\t\tme.responseData = loader.data;\n\t\t\tme.onError(e.text);\n\t\t});\n\t\tloader.addEventListener( \"securityError\", function(e:flash.events.SecurityErrorEvent){\n\t\t\tme.req = null;\n\t\t\tme.onError(e.text);\n\t\t});\n\n\t\t// headers\n\t\tvar param = false;\n\t\tvar vars = new flash.net.URLVariables();\n\t\tfor( p in params ){\n\t\t\tparam = true;\n\t\t\tReflect.setField(vars,p.param,p.value);\n\t\t}\n\t\tvar small_url = url;\n\t\tif( param && !post ){\n\t\t\tvar k = url.split(\"?\");\n\t\t\tif( k.length > 1 ) {\n\t\t\t\tsmall_url = k.shift();\n\t\t\t\tvars.decode(k.join(\"?\"));\n\t\t\t}\n\t\t}\n\t\t// Bug in flash player 9 ???\n\t\tvar bug = small_url.split(\"xxx\");\n\n\t\tvar request = new flash.net.URLRequest( small_url );\n\t\tfor( h in headers )\n\t\t\trequest.requestHeaders.push( new flash.net.URLRequestHeader(h.header,h.value) );\n\n\t\tif( postData != null ) {\n\t\t\trequest.data = postData;\n\t\t\trequest.method = \"POST\";\n\t\t} else {\n\t\t\trequest.data = vars;\n\t\t\trequest.method = if( post ) \"POST\" else \"GET\";\n\t\t}\n\n\t\ttry {\n\t\t\tloader.load( request );\n\t\t}catch( e : Dynamic ){\n\t\t\tme.req = null;\n\t\t\tonError(\"Exception: \"+Std.string(e));\n\t\t}\n\t#elseif sys\n\t\tvar me = this;\n\t\tvar output = new haxe.io.BytesOutput();\n\t\tvar old = onError;\n\t\tvar err = false;\n\t\tonError = function(e) {\n\t\t\t#if neko\n\t\t\tme.responseData = neko.Lib.stringReference(output.getBytes());\n\t\t\t#else\n\t\t\tme.responseData = output.getBytes().toString();\n\t\t\t#end\n\t\t\terr = true;\n\t\t\t// Resetting back onError before calling it allows for a second \"retry\" request to be sent without onError being wrapped twice\n\t\t\tonError = old;\n\t\t\tonError(e);\n\t\t}\n\t\tcustomRequest(post,output);\n\t\tif( !err )\n\t\t#if neko\n\t\t\tme.onData(me.responseData = neko.Lib.stringReference(output.getBytes()));\n\t\t#else\n\t\t\tme.onData(me.responseData = output.getBytes().toString());\n\t\t#end\n\t#end\n\t}\n\n#if sys\n\n\t/**\n      Note: Deprecated in 4.0\n\t **/\n\t@:noCompletion\n\tinline public function fileTransfert( argname : String, filename : String, file : haxe.io.Input, size : Int, mimeType = \"application/octet-stream\" ) {\n\t    fileTransfer(argname, filename, file, size, mimeType);\n    }\n\n\tpublic function fileTransfer( argname : String, filename : String, file : haxe.io.Input, size : Int, mimeType = \"application/octet-stream\" ) {\n\t\tthis.file = { param : argname, filename : filename, io : file, size : size, mimeType : mimeType };\n\t}\n\n\tpublic function customRequest( post : Bool, api : haxe.io.Output, ?sock : AbstractSocket, ?method : String  ) {\n\t\tthis.responseData = null;\n\t\tvar url_regexp = ~/^(https?:\\/\\/)?([a-zA-Z\\.0-9_-]+)(:[0-9]+)?(.*)$/;\n\t\tif( !url_regexp.match(url) ) {\n\t\t\tonError(\"Invalid URL\");\n\t\t\treturn;\n\t\t}\n\t\tvar secure = (url_regexp.matched(1) == \"https://\");\n\t\tif( sock == null ) {\n\t\t\tif( secure ) {\n\t\t\t\t#if php\n\t\t\t\tsock = new php.net.SslSocket();\n\t\t\t\t#elseif java\n\t\t\t\tsock = new java.net.SslSocket();\n\t\t\t\t#elseif hxssl\n\t\t\t\t#if neko\n\t\t\t\tsock = new neko.tls.Socket();\n\t\t\t\t#else\n\t\t\t\tsock = new sys.ssl.Socket();\n\t\t\t\t#end\n\t\t\t\t#else\n\t\t\t\tthrow \"Https is only supported with -lib hxssl\";\n\t\t\t\t#end\n\t\t\t} else\n\t\t\t\tsock = new Socket();\n\t\t}\n\t\tvar host = url_regexp.matched(2);\n\t\tvar portString = url_regexp.matched(3);\n\t\tvar request = url_regexp.matched(4);\n\t\tif( request == \"\" )\n\t\t\trequest = \"/\";\n\t\tvar port = if ( portString == null || portString == \"\" ) secure ? 443 : 80 else Std.parseInt(portString.substr(1, portString.length - 1));\n\t\tvar data;\n\n\t\tvar multipart = (file != null);\n\t\tvar boundary = null;\n\t\tvar uri = null;\n\t\tif( multipart ) {\n\t\t\tpost = true;\n\t\t\tboundary = Std.string(Std.random(1000))+Std.string(Std.random(1000))+Std.string(Std.random(1000))+Std.string(Std.random(1000));\n\t\t\twhile( boundary.length < 38 )\n\t\t\t\tboundary = \"-\" + boundary;\n\t\t\tvar b = new StringBuf();\n\t\t\tfor( p in params ) {\n\t\t\t\tb.add(\"--\");\n\t\t\t\tb.add(boundary);\n\t\t\t\tb.add(\"\\r\\n\");\n\t\t\t\tb.add('Content-Disposition: form-data; name=\"');\n\t\t\t\tb.add(p.param);\n\t\t\t\tb.add('\"');\n\t\t\t\tb.add(\"\\r\\n\");\n\t\t\t\tb.add(\"\\r\\n\");\n\t\t\t\tb.add(p.value);\n\t\t\t\tb.add(\"\\r\\n\");\n\t\t\t}\n\t\t\tb.add(\"--\");\n\t\t\tb.add(boundary);\n\t\t\tb.add(\"\\r\\n\");\n\t\t\tb.add('Content-Disposition: form-data; name=\"');\n\t\t\tb.add(file.param);\n\t\t\tb.add('\"; filename=\"');\n\t\t\tb.add(file.filename);\n\t\t\tb.add('\"');\n\t\t\tb.add(\"\\r\\n\");\n\t\t\tb.add(\"Content-Type: \"+file.mimeType+\"\\r\\n\"+\"\\r\\n\");\n\t\t\turi = b.toString();\n\t\t} else {\n\t\t\tfor( p in params ) {\n\t\t\t\tif( uri == null )\n\t\t\t\t\turi = \"\";\n\t\t\t\telse\n\t\t\t\t\turi += \"&\";\n\t\t\t\turi += StringTools.urlEncode(p.param)+\"=\"+StringTools.urlEncode(p.value);\n\t\t\t}\n\t\t}\n\n\t\tvar b = new StringBuf();\n\t\tif( method != null ) {\n\t\t\tb.add(method);\n\t\t\tb.add(\" \");\n\t\t} else if( post )\n\t\t\tb.add(\"POST \");\n\t\telse\n\t\t\tb.add(\"GET \");\n\n\t\tif( Http.PROXY != null ) {\n\t\t\tb.add(\"http://\");\n\t\t\tb.add(host);\n\t\t\tif( port != 80 ) {\n\t\t\t\tb.add(\":\");\n\t\t\t\tb.add(port);\n\t\t\t}\n\t\t}\n\t\tb.add(request);\n\n\t\tif( !post && uri != null ) {\n\t\t\tif( request.indexOf(\"?\",0) >= 0 )\n\t\t\t\tb.add(\"&\");\n\t\t\telse\n\t\t\t\tb.add(\"?\");\n\t\t\tb.add(uri);\n\t\t}\n\t\tb.add(\" HTTP/1.1\\r\\nHost: \"+host+\"\\r\\n\");\n\t\tif( postData != null )\n\t\t\tb.add(\"Content-Length: \"+postData.length+\"\\r\\n\");\n\t\telse if( post && uri != null ) {\n\t\t\tif( multipart || !Lambda.exists(headers, function(h) return h.header == \"Content-Type\") ) {\n\t\t\t\tb.add(\"Content-Type: \");\n\t\t\t\tif( multipart ) {\n\t\t\t\t\tb.add(\"multipart/form-data\");\n\t\t\t\t\tb.add(\"; boundary=\");\n\t\t\t\t\tb.add(boundary);\n\t\t\t\t} else\n\t\t\t\t\tb.add(\"application/x-www-form-urlencoded\");\n\t\t\t\tb.add(\"\\r\\n\");\n\t\t\t}\n\t\t\tif( multipart )\n\t\t\t\tb.add(\"Content-Length: \"+(uri.length+file.size+boundary.length+6)+\"\\r\\n\");\n\t\t\telse\n\t\t\t\tb.add(\"Content-Length: \"+uri.length+\"\\r\\n\");\n\t\t}\n\t\tfor( h in headers ) {\n\t\t\tb.add(h.header);\n\t\t\tb.add(\": \");\n\t\t\tb.add(h.value);\n\t\t\tb.add(\"\\r\\n\");\n\t\t}\n\t\tb.add(\"\\r\\n\");\n\t\tif( postData != null)\n\t\t\tb.add(postData);\n\t\telse if( post && uri != null )\n\t\t\tb.add(uri);\n\t\ttry {\n\t\t\tif( Http.PROXY != null )\n\t\t\t\tsock.connect(new Host(Http.PROXY.host),Http.PROXY.port);\n\t\t\telse\n\t\t\t\tsock.connect(new Host(host),port);\n\t\t\tsock.write(b.toString());\n\t\t\tif( multipart ) {\n\t\t\t\tvar bufsize = 4096;\n\t\t\t\tvar buf = haxe.io.Bytes.alloc(bufsize);\n\t\t\t\twhile( file.size > 0 ) {\n\t\t\t\t\tvar size = if( file.size > bufsize ) bufsize else file.size;\n\t\t\t\t\tvar len = 0;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlen = file.io.readBytes(buf,0,size);\n\t\t\t\t\t} catch( e : haxe.io.Eof ) break;\n\t\t\t\t\tsock.output.writeFullBytes(buf,0,len);\n\t\t\t\t\tfile.size -= len;\n\t\t\t\t}\n\t\t\t\tsock.write(\"\\r\\n\");\n\t\t\t\tsock.write(\"--\");\n\t\t\t\tsock.write(boundary);\n\t\t\t\tsock.write(\"--\");\n\t\t\t}\n\t\t\treadHttpResponse(api,sock);\n\t\t\tsock.close();\n\t\t} catch( e : Dynamic ) {\n\t\t\ttry sock.close() catch( e : Dynamic ) { };\n\t\t\tonError(Std.string(e));\n\t\t}\n\t}\n\n\tfunction readHttpResponse( api : haxe.io.Output, sock : AbstractSocket ) {\n\t\t// READ the HTTP header (until \\r\\n\\r\\n)\n\t\tvar b = new haxe.io.BytesBuffer();\n\t\tvar k = 4;\n\t\tvar s = haxe.io.Bytes.alloc(4);\n\t\tsock.setTimeout(cnxTimeout);\n\t\twhile( true ) {\n\t\t\tvar p = sock.input.readBytes(s,0,k);\n\t\t\twhile( p != k )\n\t\t\t\tp += sock.input.readBytes(s,p,k - p);\n\t\t\tb.addBytes(s,0,k);\n\t\t\tswitch( k ) {\n\t\t\tcase 1:\n\t\t\t\tvar c = s.get(0);\n\t\t\t\tif( c == 10 )\n\t\t\t\t\tbreak;\n\t\t\t\tif( c == 13 )\n\t\t\t\t\tk = 3;\n\t\t\t\telse\n\t\t\t\t\tk = 4;\n\t\t\tcase 2:\n\t\t\t\tvar c = s.get(1);\n\t\t\t\tif( c == 10 ) {\n\t\t\t\t\tif( s.get(0) == 13 )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tk = 4;\n\t\t\t\t} else if( c == 13 )\n\t\t\t\t\tk = 3;\n\t\t\t\telse\n\t\t\t\t\tk = 4;\n\t\t\tcase 3:\n\t\t\t\tvar c = s.get(2);\n\t\t\t\tif( c == 10 ) {\n\t\t\t\t\tif( s.get(1) != 13 )\n\t\t\t\t\t\tk = 4;\n\t\t\t\t\telse if( s.get(0) != 10 )\n\t\t\t\t\t\tk = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if( c == 13 ) {\n\t\t\t\t\tif( s.get(1) != 10 || s.get(0) != 13 )\n\t\t\t\t\t\tk = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tk = 3;\n\t\t\t\t} else\n\t\t\t\t\tk = 4;\n\t\t\tcase 4:\n\t\t\t\tvar c = s.get(3);\n\t\t\t\tif( c == 10 ) {\n\t\t\t\t\tif( s.get(2) != 13 )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if( s.get(1) != 10 || s.get(0) != 13 )\n\t\t\t\t\t\tk = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if( c == 13 ) {\n\t\t\t\t\tif( s.get(2) != 10 || s.get(1) != 13 )\n\t\t\t\t\t\tk = 3;\n\t\t\t\t\telse\n\t\t\t\t\t\tk = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#if neko\n\t\tvar headers = neko.Lib.stringReference(b.getBytes()).split(\"\\r\\n\");\n\t\t#else\n\t\tvar headers = b.getBytes().toString().split(\"\\r\\n\");\n\t\t#end\n\t\tvar response = headers.shift();\n\t\tvar rp = response.split(\" \");\n\t\tvar status = Std.parseInt(rp[1]);\n\t\tif( status == 0 || status == null )\n\t\t\tthrow \"Response status error\";\n\n\t\t// remove the two lasts \\r\\n\\r\\n\n\t\theaders.pop();\n\t\theaders.pop();\n\t\tresponseHeaders = new haxe.ds.StringMap();\n\t\tvar size = null;\n\t\tvar chunked = false;\n\t\tfor( hline in headers ) {\n\t\t\tvar a = hline.split(\": \");\n\t\t\tvar hname = a.shift();\n\t\t\tvar hval = if( a.length == 1 ) a[0] else a.join(\": \");\n\t\t\thval = StringTools.ltrim( StringTools.rtrim( hval ) );\n\t\t\tresponseHeaders.set(hname, hval);\n\t\t\tswitch(hname.toLowerCase())\n\t\t\t{\n\t\t\t\tcase \"content-length\":\n\t\t\t\t\tsize = Std.parseInt(hval);\n\t\t\t\tcase \"transfer-encoding\":\n\t\t\t\t\tchunked = (hval.toLowerCase() == \"chunked\");\n\t\t\t}\n\t\t}\n\n\t\tonStatus(status);\n\n\t\tvar chunk_re = ~/^([0-9A-Fa-f]+)[ ]*\\r\\n/m;\n\t\tchunk_size = null;\n\t\tchunk_buf = null;\n\n\t\tvar bufsize = 1024;\n\t\tvar buf = haxe.io.Bytes.alloc(bufsize);\n\t\tif( size == null ) {\n\t\t\tif( !noShutdown )\n\t\t\t\tsock.shutdown(false,true);\n\t\t\ttry {\n\t\t\t\twhile( true ) {\n\t\t\t\t\tvar len = sock.input.readBytes(buf,0,bufsize);\n\t\t\t\t\tif( chunked ) {\n\t\t\t\t\t\tif( !readChunk(chunk_re,api,buf,len) )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else\n\t\t\t\t\t\tapi.writeBytes(buf,0,len);\n\t\t\t\t}\n\t\t\t} catch( e : haxe.io.Eof ) {\n\t\t\t}\n\t\t} else {\n\t\t\tapi.prepare(size);\n\t\t\ttry {\n\t\t\t\twhile( size > 0 ) {\n\t\t\t\t\tvar len = sock.input.readBytes(buf,0,if( size > bufsize ) bufsize else size);\n\t\t\t\t\tif( chunked ) {\n\t\t\t\t\t\tif( !readChunk(chunk_re,api,buf,len) )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else\n\t\t\t\t\t\tapi.writeBytes(buf,0,len);\n\t\t\t\t\tsize -= len;\n\t\t\t\t}\n\t\t\t} catch( e : haxe.io.Eof ) {\n\t\t\t\tthrow \"Transfer aborted\";\n\t\t\t}\n\t\t}\n\t\tif( chunked && (chunk_size != null || chunk_buf != null) )\n\t\t\tthrow \"Invalid chunk\";\n\t\tif( status < 200 || status >= 400 )\n\t\t\tthrow \"Http Error #\"+status;\n\t\tapi.close();\n\t}\n\n\tfunction readChunk(chunk_re : EReg, api : haxe.io.Output, buf : haxe.io.Bytes, len ) {\n\t\tif( chunk_size == null ) {\n\t\t\tif( chunk_buf != null ) {\n\t\t\t\tvar b = new haxe.io.BytesBuffer();\n\t\t\t\tb.add(chunk_buf);\n\t\t\t\tb.addBytes(buf,0,len);\n\t\t\t\tbuf = b.getBytes();\n\t\t\t\tlen += chunk_buf.length;\n\t\t\t\tchunk_buf = null;\n\t\t\t}\n\t\t\t#if neko\n\t\t\tif( chunk_re.match(neko.Lib.stringReference(buf)) ) {\n\t\t\t#else\n\t\t\tif( chunk_re.match(buf.toString()) ) {\n\t\t\t#end\n\t\t\t\tvar p = chunk_re.matchedPos();\n\t\t\t\tif( p.len <= len ) {\n\t\t\t\t\tvar cstr = chunk_re.matched(1);\n\t\t\t\t\tchunk_size = Std.parseInt(\"0x\"+cstr);\n\t\t\t\t\tif( cstr == \"0\" ) {\n\t\t\t\t\t\tchunk_size = null;\n\t\t\t\t\t\tchunk_buf = null;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tlen -= p.len;\n\t\t\t\t\treturn readChunk(chunk_re,api,buf.sub(p.len,len),len);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// prevent buffer accumulation\n\t\t\tif( len > 10 ) {\n\t\t\t\tonError(\"Invalid chunk\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tchunk_buf = buf.sub(0,len);\n\t\t\treturn true;\n\t\t}\n\t\tif( chunk_size > len ) {\n\t\t\tchunk_size -= len;\n\t\t\tapi.writeBytes(buf,0,len);\n\t\t\treturn true;\n\t\t}\n\t\tvar end = chunk_size + 2;\n\t\tif( len >= end ) {\n\t\t\tif( chunk_size > 0 )\n\t\t\t\tapi.writeBytes(buf,0,chunk_size);\n\t\t\tlen -= end;\n\t\t\tchunk_size = null;\n\t\t\tif( len == 0 )\n\t\t\t\treturn true;\n\t\t\treturn readChunk(chunk_re,api,buf.sub(end,len),len);\n\t\t}\n\t\tif( chunk_size > 0 )\n\t\t\tapi.writeBytes(buf,0,chunk_size);\n\t\tchunk_size -= len;\n\t\treturn true;\n\t}\n\n#end\n\n\t/**\n\t\tThis method is called upon a successful request, with `data` containing\n\t\tthe result String.\n\n\t\tThe intended usage is to bind it to a custom function:\n\t\t`httpInstance.onData = function(data) { // handle result }`\n\t**/\n\tpublic dynamic function onData( data : String ) {\n\t}\n\n\t/**\n\t\tThis method is called upon a request error, with `msg` containing the\n\t\terror description.\n\n\t\tThe intended usage is to bind it to a custom function:\n\t\t`httpInstance.onError = function(msg) { // handle error }`\n\t**/\n\tpublic dynamic function onError( msg : String ) {\n\t}\n\n\t/**\n\t\tThis method is called upon a Http status change, with `status` being the\n\t\tnew status.\n\n\t\tThe intended usage is to bind it to a custom function:\n\t\t`httpInstance.onStatus = function(status) { // handle status }`\n\t**/\n\tpublic dynamic function onStatus( status : Int ) {\n\t}\n\n#if !flash\n\t/**\n\t\tMakes a synchronous request to `url`.\n\n\t\tThis creates a new Http instance and makes a GET request by calling its\n\t\trequest(false) method.\n\n\t\tIf `url` is null, the result is unspecified.\n\t**/\n\tpublic static function requestUrl( url : String ) : String {\n\t\tvar h = new Http(url);\n\t#if js\n\t\th.async = false;\n\t#end\n\t\tvar r = null;\n\t\th.onData = function(d){\n\t\t\tr = d;\n\t\t}\n\t\th.onError = function(e){\n\t\t\tthrow e;\n\t\t}\n\t\th.request(false);\n\t\treturn r;\n\t}\n#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\nprivate class StringMapIterator<T> {\n\tvar map : StringMap<T>;\n\tvar keys : Array<String>;\n\tvar index : Int;\n\tvar count : Int;\n\tpublic inline function new(map:StringMap<T>, keys:Array<String>) {\n\t\tthis.map = map;\n\t\tthis.keys = keys;\n\t\tthis.index = 0;\n\t\tthis.count = keys.length;\n\t}\n\tpublic inline function hasNext() {\n\t\treturn index < count;\n\t}\n\tpublic inline function next() {\n\t\treturn map.get(keys[index++]);\n\t}\n}\n\n@:coreApi class StringMap<T> implements haxe.Constraints.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\tprivate var rh : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tinline function isReserved(key:String) : Bool {\n\t\treturn untyped __js__(\"__map_reserved\")[key] != null;\n\t}\n\n\tpublic inline function set( key : String, value : T ) : Void {\n\t\tif( isReserved(key) )\n\t\t\tsetReserved(key, value);\n\t\telse\n\t\t\th[cast key] = value;\n\t}\n\n\tpublic inline function get( key : String ) : Null<T> {\n\t\tif( isReserved(key) )\n\t\t\treturn getReserved(key);\n\t\treturn h[cast key];\n\t}\n\n\tpublic inline function exists( key : String ) : Bool {\n\t\tif( isReserved(key) )\n\t\t\treturn existsReserved(key);\n\t\treturn h.hasOwnProperty(key);\n\t}\n\n\tfunction setReserved( key : String, value : T ) : Void {\n\t\tif( rh == null ) rh = {};\n\t\trh[cast \"$\"+key] = value;\n\t}\n\n\tfunction getReserved( key : String ) : Null<T> {\n\t\treturn rh == null ? null : rh[cast \"$\"+key];\n\t}\n\n\tfunction existsReserved( key : String ) : Bool {\n\t\tif( rh == null ) return false;\n\t\treturn untyped rh.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tif( isReserved(key) ) {\n\t\t\tkey = \"$\" + key;\n\t\t\tif( rh == null || !rh.hasOwnProperty(key) ) return false;\n\t\t\tuntyped __js__(\"delete\")(rh[key]);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif( !h.hasOwnProperty(key) )\n\t\t\t\treturn false;\n\t\t\tuntyped __js__(\"delete\")(h[key]);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\treturn arrayKeys().iterator();\n\t}\n\t\n\tfunction arrayKeys() : Array<String> {\n\t\tvar out = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\tout.push(key);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\tif( rh != null ) untyped {\n\t\t\t__js__(\"for( var key in this.rh ) {\");\n\t\t\t\tif( key.charCodeAt(0) == \"$\".code )\n\t\t\t\t\tout.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn out;\n\t}\n\n\tpublic inline function iterator() : Iterator<T> {\n\t\treturn new StringMapIterator(this, arrayKeys());\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar keys = arrayKeys();\n\t\tfor( i in 0...keys.length ) {\n\t\t\tvar k = keys[i];\n\t\t\ts.add(k);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(k)));\n\t\t\tif( i < keys.length )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\tstatic function __init__() : Void {\n\t\tuntyped __js__(\"var __map_reserved = {}\");\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.rtti;\n\n/**\n\tAn api to access classes and enums metadata at runtime.\n**/\nclass Meta {\n\n\t/**\n\t\tReturns the metadata that were declared for the given type (class or enum)\n\t**/\n\tpublic static function getType( t : Dynamic ) : Dynamic<Array<Dynamic>> {\n\t\tvar meta = getMeta(t);\n\t\treturn (meta == null || meta.obj == null) ? {} : meta.obj;\n\t}\n\n\tprivate static function getMeta(t:Dynamic):Dynamic\n\t{\n#if (java || cs)\n\t\tvar ret = Reflect.field(t, \"__meta__\");\n\t\tif (ret == null && Std.is(t,Class))\n\t\t{\n#if java\n\t\t\tvar interf = java.Lib.toNativeType(t).isInterface();\n#elseif cs\n\t\t\tvar interf = cs.Lib.toNativeType(t).IsInterface;\n#end\n\t\t\tif (interf)\n\t\t\t{\n\t\t\t\tvar name = Type.getClassName(t),\n\t\t\t\t    cls = Type.resolveClass(name + '_HxMeta');\n\t\t\t\tif (cls != null)\n\t\t\t\t\treturn Reflect.field(cls, \"__meta__\");\n\t\t\t}\n\t\t}\n\t\treturn ret;\n#else\n\t\treturn untyped t.__meta__;\n#end\n\t}\n\n\t/**\n\t\tReturns the metadata that were declared for the given class static fields\n\t**/\n\tpublic static function getStatics( t : Dynamic ) : Dynamic<Dynamic<Array<Dynamic>>> {\n\t\tvar meta = getMeta(t);\n\t\treturn (meta == null || meta.statics == null) ? {} : meta.statics;\n\t}\n\n\t/**\n\t\tReturns the metadata that were declared for the given class fields or enum constructors\n\t**/\n\tpublic static function getFields( t : Dynamic ) : Dynamic<Dynamic<Array<Dynamic>>> {\n\t\tvar meta = getMeta(t);\n\t\treturn (meta == null || meta.fields == null) ? {} : meta.fields;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nprivate class HaxeError extends js.Error {\n\n\tvar val:Dynamic;\n\n\tpublic function new(val:Dynamic) untyped {\n\t\tsuper();\n\t\tthis.val = __define_feature__(\"js.Boot.HaxeError\", val);\n\t\tthis.message = String(val);\n\t\tif (js.Error.captureStackTrace) js.Error.captureStackTrace(this, HaxeError);\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped __js__(\"{}.toString\");\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn untyped js.Lib.global[name];\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nimport js.html.Storage;\nimport js.html.XMLHttpRequest;\n\nclass Browser {\n\t/** The global window object. */\n\tpublic static var window(get, never):js.html.Window;\n\tinline static function get_window() return untyped __js__(\"window\");\n\n\t/** Shortcut to Window.document. */\n\tpublic static var document(get, never):js.html.HTMLDocument;\n\tinline static function get_document() return untyped __js__(\"window.document\");\n\n\t/** Shortcut to Window.location. */\n\tpublic static var location(get, never):js.html.Location;\n\tinline static function get_location() return untyped __js__(\"window.location\");\n\n\t/** Shortcut to Window.navigator. */\n\tpublic static var navigator(get, never):js.html.Navigator;\n\tinline static function get_navigator() return untyped __js__(\"window.navigator\");\n\n\t/** Shortcut to Window.console. */\n\tpublic static var console(get, never):js.html.Console;\n\tinline static function get_console() return untyped __js__(\"window.console\");\n\n\t/**\n\t * True if a window object exists, false otherwise.\n\t *\n\t * This can be used to check if the code is being executed in a non-browser\n\t * environment such as node.js.\n\t */\n\tpublic static var supported(get, never):Bool;\n\tinline static function get_supported() return untyped __typeof__(window) != \"undefined\";\n\n\t/**\n\t * Safely gets the browser's local storage, or returns null if localStorage is unsupported or\n\t * disabled.\n\t */\n\tpublic static function getLocalStorage() : Storage\n\t{\n\t\ttry {\n\t\t\tvar s = window.localStorage;\n\t\t\ts.getItem(\"\");\n\t\t\treturn s;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Safely gets the browser's session storage, or returns null if sessionStorage is unsupported\n\t * or disabled.\n\t */\n\tpublic static function getSessionStorage() : Storage\n\t{\n\t\ttry {\n\t\t\tvar s = window.sessionStorage;\n\t\t\ts.getItem(\"\");\n\t\t\treturn s;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Creates an XMLHttpRequest, with a fallback to ActiveXObject for ancient versions of Internet\n\t * Explorer.\n\t */\n\tpublic static function createXMLHttpRequest() : XMLHttpRequest\n\t{\n\t\tif( untyped __js__(\"typeof XMLHttpRequest\") != \"undefined\" ) {\n\t\t\treturn new XMLHttpRequest();\n\t\t}\n\t\tif( untyped __js__(\"typeof ActiveXObject\") != \"undefined\" ) {\n\t\t\treturn untyped __new__(\"ActiveXObject\",\"Microsoft.XMLHTTP\");\n\t\t}\n\t\tthrow \"Unable to create XMLHttpRequest object.\";\n\t}\n\n\t/**\n\t\tDisplay an alert message box containing the given message. See also `Window.alert()`.\n\t**/\n\tpublic static function alert( v : Dynamic ) {\n\t\t@:privateAccess window.alert(Boot.__string_rec(v,\"\"));\n\t}\n}\n","package js.client;\n\nimport common.client.util.BuildInfo;\nimport jQuery.JQuery;\nimport js.Browser;\n\nusing DateTools;\n\n@:keep\nclass App\n{\n  @inject public var buildInfo:BuildInfo;\n\n  private var _appTitleElement = new JQuery('.app-title');\n  private var _compileDateTimeElement = new JQuery('.compile-date-time');\n  private var _currentDateTimeElement = new JQuery('.current-date-time');\n  private var _swfContainerElement = new JQuery('#swfContainer');\n  private var _jsLogElement = new JQuery('#jsLog');\n\n  public function new()\n  {\n    _init();\n  }\n\n  @post //this method is called automatically because of @post metadata\n  public function injectionsReady():Void\n  {\n    if(_appTitleElement == null)\n    {\n      _initUI();\n    }\n  }\n\n  private function _init():Void\n  {\n    trace('_init()');\n\n    _initUI();\n  }\n\n  private function _initUI():Void\n  {\n    trace({'_appTitleElement':_appTitleElement});\n    trace({'_compileDateTimeElement':_compileDateTimeElement});\n    trace({'_currentDateTimeElement':_currentDateTimeElement});\n    trace({'_swfContainerElement':_swfContainerElement});\n\n    //you can use methods etc using string interpolation using the ${} syntax\n    //also notice .format() at the end of the string.\n    //it's available as a method because of static extension and i have using DateTools; at the top of this file\n    _compileDateTimeElement.text('[last compile date-time ${BuildInfo.COMPILE_DATE_TIME.format(\"%m/%d/%Y %r\")}]');\n\n    //haxe's ability to remove traces won't remove direct calls to console Browser.console.log()\n    //but i added a gulp task to strip debug calls for the release target\n    Browser.console.log(\"this will only appear in the debug version of the js output\");\n  }\n}","package minject;\n\nimport Map;\n\nclass ClassMap<V> implements IMap<Class<Dynamic>, V>\n{\n\tvar map:Map<String, V>;\n\n\tpublic function new()\n\t{\n\t\tmap = new Map();\n\t}\n\n\tpublic function get(k:Class<Dynamic>):Null<V>\n\t{\n\t\treturn map.get(getKey(k));\n\t}\n\n\tpublic function set(k:Class<Dynamic>, v:V):Void\n\t{\n\t\tmap.set(getKey(k), v);\n\t}\n\n\tpublic function exists(k:Class<Dynamic>):Bool\n\t{\n\t\treturn map.exists(getKey(k));\n\t}\n\n\tpublic function remove(k:Class<Dynamic>):Bool\n\t{\n\t\treturn map.remove(getKey(k));\n\t}\n\n\tpublic function keys():Iterator<Class<Dynamic>>\n\t{\n\t\treturn cast [for (k in map.keys()) Type.resolveClass(k)].iterator();\n\t}\n\n\tpublic function iterator():Iterator<V>\n\t{\n\t\treturn map.iterator();\n\t}\n\n\tpublic function toString()\n\t{\n\t\treturn map.toString();\n\t}\n\n\tinline function getKey(k:Class<Dynamic>)\n\t{\n\t\treturn Type.getClassName(k);\n\t}\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject;\n\nimport minject.result.InjectionResult;\n\nclass InjectionConfig\n{\n\tpublic var request:Class<Dynamic>;\n\tpublic var injectionName:String;\n\n\tvar injector:Injector;\n\tvar result:InjectionResult;\n\t\n\tpublic function new(request:Class<Dynamic>, injectionName:String)\n\t{\n\t\tthis.request = request;\n\t\tthis.injectionName = injectionName;\n\t}\n\n\tpublic function getResponse(injector:Injector):Dynamic\n\t{\n\t\tif (this.injector != null) injector = this.injector;\n\n\t\tif (result != null) return result.getResponse(injector);\n\t\t\n\t\tvar parentConfig = injector.getAncestorMapping(request, injectionName);\n\t\tif (parentConfig != null) return parentConfig.getResponse(injector);\n\n\t\treturn null;\n\t}\n\n\tpublic function hasResponse(injector:Injector):Bool\n\t{\n\t\treturn (result != null);\n\t}\n\n\tpublic function hasOwnResponse():Bool\n\t{\n\t\treturn (result != null);\n\t}\n\n\tpublic function setResult(result:InjectionResult):Void\n\t{\n\t\t#if debug\n\t\tif (this.result != null && result != null)\n\t\t{\n\t\t\ttrace('Warning: Injector contains ${this.toString()}.\\nAttempting to overwrite this ' +\n\t\t\t\t'with mapping for [${result.toString()}].\\nIf you have overwritten this mapping ' +\n\t\t\t\t'intentionally you can use `injector.unmap()` prior to your replacement mapping ' +\n\t\t\t\t'in order to avoid seeing this message.');\n\t\t}\n\t\t#end\n\t\tthis.result = result;\n\t}\n\n\tpublic function setInjector(injector:Injector):Void\n\t{\n\t\tthis.injector = injector;\n\t}\n\n\tpublic function toString():String\n\t{\n\t\tvar named = injectionName != null && injectionName != \"\" ? ' named \"$injectionName\" and' : \"\";\n\t\treturn 'rule: [' + Type.getClassName(request) + ']$named mapped to [$result]';\n\t}\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject;\n\nimport haxe.rtti.Meta;\nimport haxe.ds.WeakMap;\nimport haxe.ds.ObjectMap;\nimport minject.point.ConstructorInjectionPoint;\nimport minject.point.InjectionPoint;\nimport minject.point.MethodInjectionPoint;\nimport minject.point.NoParamsConstructorInjectionPoint;\nimport minject.point.PostConstructInjectionPoint;\nimport minject.point.PropertyInjectionPoint;\nimport minject.result.InjectClassResult;\nimport minject.result.InjectOtherRuleResult;\nimport minject.result.InjectSingletonResult;\nimport minject.result.InjectValueResult;\n\n/**\n\tThe dependency injector.\n**/\n#if !macro @:build(minject.Macro.addMetadata()) #end class Injector\n{\n\t/**\n\t\tA set of instances that have already had their dependencies satisfied by the injector.\n\t**/\n\tpublic var attendedToInjectees(default, null):InjecteeSet;\n\n\t/**\n\t\tThe parent of this injector.\n\t**/\n\tpublic var parentInjector(default, set):Injector;\n\n\tvar injectionConfigs:Map<String, InjectionConfig>;\n\tvar injecteeDescriptions:ClassMap<InjecteeDescription>;\n\t\n\tpublic function new()\n\t{\n\t\tinjectionConfigs = new Map();\n\t\tinjecteeDescriptions = new ClassMap();\n\t\tattendedToInjectees = new InjecteeSet();\n\t}\n\t\n\t/**\n\t\tWhen asked for an instance of the class `whenAskedFor` inject the instance `useValue`.\n\t\t\n\t\tThis is used to register an existing instance with the injector and treat it like a \n\t\tSingleton.\n\t\t\n\t\t@param whenAskedFor A class or interface\n\t\t@param useValue An instance\n\t\t@param named An optional name (id)\n\t\t\n\t\t@returns A reference to the rule for this injection. To be used with `mapRule`\n\t**/\n\tpublic function mapValue(whenAskedFor:Class<Dynamic>, useValue:Dynamic, ?named:String = \"\"):Dynamic\n\t{\n\t\tvar config = getMapping(whenAskedFor, named);\n\t\tconfig.setResult(new InjectValueResult(useValue));\n\t\treturn config;\n\t}\n\t\n\t/**\n\t\tWhen asked for an instance of the class `whenAskedFor` inject a new instance of \n\t\t`instantiateClass`.\n\t\t\n\t\tThis will create a new instance for each injection.\n\t\t\n\t\t@param whenAskedFor A class or interface\n\t\t@param instantiateClass A class to instantiate\n\t\t@param named An optional name (id)\n\n\t\t@returns A reference to the rule for this injection. To be used with `mapRule`\n\t**/\n\tpublic function mapClass(whenAskedFor:Class<Dynamic>, instantiateClass:Class<Dynamic>, ?named:String=\"\"):Dynamic\n\t{\n\t\tvar config = getMapping(whenAskedFor, named);\n\t\tconfig.setResult(new InjectClassResult(instantiateClass));\n\t\treturn config;\n\t}\n\t\n\t/**\n\t\tWhen asked for an instance of the class `whenAskedFor` inject an instance of `whenAskedFor`.\n\t\t\n\t\tThis will create an instance on the first injection, but will re-use that instance for \n\t\tsubsequent injections.\n\t\t\n\t\t@param whenAskedFor A class or interface\n\t\t@param named An optional name (id)\n\t\t\n\t\t@returns A reference to the rule for this injection. To be used with `mapRule`\n\t**/\n\tpublic function mapSingleton(whenAskedFor:Class<Dynamic>, ?named:String=\"\") :Dynamic\n\t{\n\t\treturn mapSingletonOf(whenAskedFor, whenAskedFor, named);\n\t}\n\t\n\t/**\n\t\tWhen asked for an instance of the class `whenAskedFor`\n\t\tinject an instance of `useSingletonOf`.\n\t\t\n\t\tThis will create an instance on the first injection, but will re-use that instance for \n\t\tsubsequent injections.\n\t\t\n\t\t@param whenAskedFor A class or interface\n\t\t@param useSingletonOf A class to instantiate\n\t\t@param named An optional name (id)\n\t\t\n\t\t@returns A reference to the rule for this injection. To be used with `mapRule`\n\t**/\n\tpublic function mapSingletonOf(whenAskedFor:Class<Dynamic>, useSingletonOf:Class<Dynamic>, ?named:String=\"\"):Dynamic\n\t{\n\t\tvar config = getMapping(whenAskedFor, named);\n\t\tconfig.setResult(new InjectSingletonResult(useSingletonOf));\n\t\treturn config;\n\t}\n\t\n\t/**\n\t\tWhen asked for an instance of the class `whenAskedFor`\n\t\tuse rule `useRule` to determine the correct injection.\n\t\t\n\t\tThis will use whatever injection is set by the given injection rule as created using one \n\t\tof the other mapping methods.\n\t\t\n\t\t@param whenAskedFor A class or interface\n\t\t@param useRule The rule to use for the injection\n\t\t@param named An optional name (id)\n\t\t\n\t\t@returns A reference to the rule for this injection. To be used with `mapRule`\n\t**/\n\tpublic function mapRule(whenAskedFor:Class<Dynamic>, useRule:Dynamic, ?named:String = \"\"):Dynamic\n\t{\n\t\tvar config = getMapping(whenAskedFor, named);\n\t\tconfig.setResult(new InjectOtherRuleResult(useRule));\n\t\treturn useRule;\n\t}\n\t\n\tpublic function getMapping(forClass:Class<Dynamic>, ?named:String=\"\"):InjectionConfig\n\t{\n\t\tvar requestName = getClassName(forClass) + \"#\" + named;\n\t\t\n\t\tif (injectionConfigs.exists(requestName))\n\t\t{\n\t\t\treturn injectionConfigs.get(requestName);\n\t\t}\n\t\t\n\t\tvar config = new InjectionConfig(forClass, named);\n\t\tinjectionConfigs.set(requestName, config);\n\t\treturn config;\n\t}\n\t\n\t/**\n\t\tPerform an injection into an object, satisfying all it's dependencies\n\t\t\n\t\tThe `Injector` should throw an `Error` if it can't satisfy all dependencies of the injectee.\n\t\t\n\t\t@param target The object to inject into - the Injectee\n\t**/\n\tpublic function injectInto(target:Dynamic):Void\n\t{\n\t\tif (attendedToInjectees.contains(target))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tattendedToInjectees.add(target);\n\n\t\t// get injection points or cache them if this target's class wasn't encountered before\n\t\tvar targetClass = Type.getClass(target);\n\n\t\tvar injecteeDescription:InjecteeDescription = null;\n\n\t\tif (injecteeDescriptions.exists(targetClass))\n\t\t{\n\t\t\tinjecteeDescription = injecteeDescriptions.get(targetClass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinjecteeDescription = getInjectionPoints(targetClass);\n\t\t}\n\n\t\tif (injecteeDescription == null) return;\n\n\t\tvar injectionPoints:Array<Dynamic> = injecteeDescription.injectionPoints;\n\t\tvar length:Int = injectionPoints.length;\n\n\t\tfor (i in 0...length)\n\t\t{\n\t\t\tvar injectionPoint:InjectionPoint = injectionPoints[i];\n\t\t\tinjectionPoint.applyInjection(target, this);\n\t\t}\n\t}\n\t\n\t/**\n\t\tConstructs an instance of theClass without satifying its dependencies.\n\t**/\n\tpublic function construct<T>(theClass:Class<T>):T\n\t{\n\t\tvar injecteeDescription:InjecteeDescription;\n\n\t\tif (injecteeDescriptions.exists(theClass))\n\t\t{\n\t\t\tinjecteeDescription = injecteeDescriptions.get(theClass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinjecteeDescription = getInjectionPoints(theClass);\n\t\t}\n\n\t\tvar injectionPoint:InjectionPoint = injecteeDescription.ctor;\n\t\treturn injectionPoint.applyInjection(theClass, this);\n\t}\n\n\t/**\n\t\tCreate an object of the given class, supplying its dependencies as constructor parameters \n\t\tif the used DI solution has support for constructor injection\n\t\t\n\t\tAdapters for DI solutions that don't support constructor injection should just create a new \n\t\tinstance and perform setter and/or method injection on that.\n\t\t\n\t\tNOTE: This method will always create a new instance. If you need to retrieve an instance \n\t\tconsider using `getInstance`\n\t\t\n\t\tThe `Injector` should throw an `Error` if it can't satisfy all dependencies of the injectee.\n\t\t\n\t\t@param theClass The class to instantiate\n\t\t@returns The created instance\n\t**/\n\tpublic function instantiate<T>(theClass:Class<T>):T\n\t{\n\t\tvar instance = construct(theClass);\n\t\tinjectInto(instance);\n\t\treturn instance;\n\t}\n\t\n\t/**\n\t\tRemove a rule from the injector\n\n\t\t@param theClass A class or interface\n\t\t@param named An optional name (id)\n\t**/\n\tpublic function unmap(theClass:Class<Dynamic>, ?named:String=\"\"):Void\n\t{\n\t\tvar mapping = getConfigurationForRequest(theClass, named);\n\t\t\n\t\tif (mapping == null)\n\t\t{\n\t\t\tthrow 'Error while removing an injector mapping: No mapping defined for class ' + getClassName(theClass) + ', named \"' + named + '\"';\n\t\t}\n\n\t\tmapping.setResult(null);\n\t}\n\n\t/**\n\t\tDoes a rule exist to satsify such a request?\n\n\t\t@param forClass A class or interface\n\t\t@param named An optional name (id)\n\t\t@returns Whether such a mapping exists\n\t**/\n\tpublic function hasMapping(forClass:Class<Dynamic>, ?named:String = ''):Bool\n\t{\n\t\tvar mapping = getConfigurationForRequest(forClass, named);\n\t\t\n\t\tif (mapping == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn mapping.hasResponse(this);\n\t}\n\n\t/**\n\t\tCreate or retrieve an instance of the given class\n\t\t\n\t\t@param ofClass The class to retrieve.\n\t\t@param named An optional name (id)\n\t\t@return An instance\n\t**/\n\tpublic function getInstance<T>(ofClass:Class<T>, ?named:String=\"\"):T\n\t{\n\t\tvar mapping = getConfigurationForRequest(ofClass, named);\n\t\t\n\t\tif (mapping == null || !mapping.hasResponse(this))\n\t\t{\n\t\t\tthrow 'Error while getting mapping response: No mapping defined for class ' + getClassName(ofClass) + ', named \"' + named + '\"';\n\t\t}\n\n\t\treturn mapping.getResponse(this);\n\t}\n\t\n\t/**\n\t\tCreate an injector that inherits rules from its parent\n\t\t\n\t\t@returns The injector \n\t**/\n\tpublic function createChildInjector():Injector\n\t{\n\t\tvar injector = new Injector();\n\t\tinjector.parentInjector = this;\n\t\treturn injector;\n\t}\n\n\t/**\n\t\tSearches for an injection mapping in the ancestry of the injector. This method is called \n\t\twhen a dependency cannot be satisfied by this injector.\n\t**/\n\tpublic function getAncestorMapping(forClass:Class<Dynamic>, named:String=null):InjectionConfig\n\t{\n\t\tvar parent = parentInjector;\n\n\t\twhile (parent != null)\n\t\t{\n\t\t\tvar parentConfig = parent.getConfigurationForRequest(forClass, named, false);\n\n\t\t\tif (parentConfig != null && parentConfig.hasOwnResponse())\n\t\t\t{\n\t\t\t\treturn parentConfig;\n\t\t\t}\n\n\t\t\tparent = parent.parentInjector;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tfunction getInjectionPoints(forClass:Class<Dynamic>):InjecteeDescription\n\t{\n\t\tvar typeMeta = Meta.getType(forClass);\n\n\t\t#if debug\n\t\tif (typeMeta != null && Reflect.hasField(typeMeta, \"interface\"))\n\t\t\tthrow \"Interfaces can't be used as instantiatable classes.\";\n\t\t#end\n\n\t\tvar fieldsMeta = getFields(forClass);\n\n\t\tvar ctorInjectionPoint:InjectionPoint = null;\n\t\tvar injectionPoints:Array<InjectionPoint> = [];\n\t\tvar postConstructMethodPoints:Array<Dynamic> = [];\n\t\t\n\t\tfor (field in Reflect.fields(fieldsMeta))\n\t\t{\n\t\t\tvar fieldMeta:Dynamic = Reflect.field(fieldsMeta, field);\n\t\t\t// fieldMeta.name = field;\n\n\t\t\tvar inject = Reflect.hasField(fieldMeta, \"inject\");\n\t\t\tvar post = Reflect.hasField(fieldMeta, \"post\");\n\t\t\tvar type = Reflect.field(fieldMeta, \"type\");\n\t\t\tvar args = Reflect.field(fieldMeta, \"args\");\n\t\t\t\n\t\t\tif (field == \"_\") // constructor\n\t\t\t{\n\t\t\t\tif (args.length > 0)\n\t\t\t\t{\n\t\t\t\t\tctorInjectionPoint = new ConstructorInjectionPoint(fieldMeta.args);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Reflect.hasField(fieldMeta, \"args\")) // method\n\t\t\t{\n\t\t\t\tif (inject) // injection\n\t\t\t\t{\n\t\t\t\t\tvar point = new MethodInjectionPoint(field, fieldMeta.args);\n\t\t\t\t\tinjectionPoints.push(point);\n\t\t\t\t}\n\t\t\t\telse if (post) // post construction\n\t\t\t\t{\n\t\t\t\t\tvar order = fieldMeta.post == null ? 0 : fieldMeta.post[0];\n\t\t\t\t\tvar point = new PostConstructInjectionPoint(field, order);\n\t\t\t\t\tpostConstructMethodPoints.push(point);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type != null) // property\n\t\t\t{\n\t\t\t\tvar name = fieldMeta.inject == null ? null : fieldMeta.inject[0];\n\t\t\t\tvar point = new PropertyInjectionPoint(field, fieldMeta.type[0], name);\n\t\t\t\tinjectionPoints.push(point);\n\t\t\t}\n\t\t}\n\n\t\tif (postConstructMethodPoints.length > 0)\n\t\t{\n\t\t\tpostConstructMethodPoints.sort(function(a, b) { return a.order - b.order; });\n\t\t\tfor (point in postConstructMethodPoints) injectionPoints.push(point);\n\t\t}\n\n\t\tif (ctorInjectionPoint == null)\n\t\t\tctorInjectionPoint = new NoParamsConstructorInjectionPoint();\n\n\t\tvar injecteeDescription = new InjecteeDescription(ctorInjectionPoint, injectionPoints);\n\t\tinjecteeDescriptions.set(forClass, injecteeDescription);\n\t\treturn injecteeDescription;\n\t}\n\n\tfunction getConfigurationForRequest(forClass:Class<Dynamic>, named:String, ?traverseAncestors:Bool=true):InjectionConfig\n\t{\n\t\tvar requestName = getClassName(forClass) + '#' + named;\n\t\t\n\t\tif (!injectionConfigs.exists(requestName))\n\t\t{\n\t\t\tif (traverseAncestors && parentInjector != null \n\t\t\t\t&& parentInjector.hasMapping(forClass, named))\n\t\t\t\t\treturn getAncestorMapping(forClass, named);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn injectionConfigs.get(requestName);\n\t}\n\n\tfunction set_parentInjector(value:Injector):Injector\n\t{\n\t\t// restore own map of worked injectees if parent injector is removed\n\t\tif (parentInjector != null && value == null) attendedToInjectees = new InjecteeSet();\n\n\t\tparentInjector = value;\n\n\t\t// use parent's map of worked injectees\n\t\tif (parentInjector != null) attendedToInjectees = parentInjector.attendedToInjectees;\n\n\t\treturn parentInjector;\n\t}\n\n\tfunction getClassName(forClass:Class<Dynamic>):String\n\t{\n\t\tif (forClass == null) return \"Dynamic\";\n\t\telse return Type.getClassName(forClass);\n\t}\n\n\tfunction getFields(type:Class<Dynamic>)\n\t{\n\t\tvar meta = {};\n\t\twhile (type != null)\n\t\t{\n\t\t\tvar typeMeta = haxe.rtti.Meta.getFields(type);\n\t\t\tfor (field in Reflect.fields(typeMeta))\n\t\t\t\tReflect.setField(meta, field, Reflect.field(typeMeta, field));\n\t\t\ttype = Type.getSuperClass(type);\n\t\t}\n\t\treturn meta;\n\t}\n}\n\n/**\n\tContains the set of objects which have been injected into.\n\t \n\tUnder dynamic languages that don't support weak references this set a \n\thidden property on an injectee when added, to mark it as injected. This is \n\tto avoid storing a direct reference of it here, causing it never to be \n\tavailable for GC.\n**/\nclass InjecteeSet\n{\n\t#if (flash9 || java || php)\n\tvar map:WeakMap<{}, Bool>;\n\t#elseif cpp\n\tvar map:ObjectMap<{}, Bool>;\n\t#end\n\n\tpublic function new()\n\t{\n\t\t#if (flash9 || java || php)\n\t\tmap = new WeakMap<{}, Bool>();\n\t\t#elseif cpp\n\t\tmap = new ObjectMap<{}, Bool>();\n\t\t#end\n\t}\n\n\tpublic function add(value:Dynamic)\n\t{\n\t\t#if (flash9 || cpp || java || php)\n\t\tmap.set(value, true);\n\t\t#else\n\t\tvalue.__injected__ = true;\n\t\t#end\n\t}\n\n\tpublic function contains(value:Dynamic)\n\t{\n\t\t#if (flash9 || cpp || java || php)\n\t\treturn map.exists(value);\n\t\t#else\n\t\treturn value.__injected__ == true;\n\t\t#end\n\t}\n\n\tpublic function remove(value:Dynamic)\n\t{\n\t\t#if (flash9 || cpp || java || php)\n\t\tmap.remove(value);\n\t\t#else\n\t\tReflect.deleteField(value, \"__injected__\");\n\t\t#end\n\t}\n\n\t// deprecated\n\tinline public function delete(value:Dynamic) remove(value);\n\n\t/**\n\t\tUnder dynamic targets that don't support weak refs (js, avm1, neko) this will always \n\t\treturn an empty iterator due to values not being stored in this set. This is to avoid \n\t\tmemory leaks.\n\t**/\n\tpublic function iterator()\n\t{\n\t\t#if (flash9 || cpp || java || php)\n\t\treturn map.iterator();\n\t\t#else\n\t\treturn [].iterator();\n\t\t#end\n\t}\n}\n\nclass InjecteeDescription\n{\n\tpublic var ctor:InjectionPoint;\n\tpublic var injectionPoints:Array<InjectionPoint>;\n \n\tpublic function new(ctor:InjectionPoint, injectionPoints:Array<InjectionPoint>)\n\t{\n\t\tthis.ctor = ctor;\n\t\tthis.injectionPoints = injectionPoints;\n\t}\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject.point;\n\nimport minject.Injector;\n\nclass MethodInjectionPoint implements InjectionPoint\n{\n\tpublic var name(default, null):String;\n\tpublic var args(default, null):Array<ArgInjectionInfo>;\n\t\n\tpublic function new(name:String, args:Array<ArgInjectionInfo>)\n\t{\n\t\tthis.name = name;\n\t\tthis.args = args;\n\n\t\t#if debug\n\t\tfor (arg in args)\n\t\t\tif (arg.type == \"Dynamic\")\n\t\t\t\tthrow 'Error in method definition of injectee. Required parameters can\\'t have non class type.';\n\t\t#end\n\t}\n\t\n\tpublic function applyInjection(target:Dynamic, injector:Injector):Dynamic\n\t{\n\t\tReflect.callMethod(target, Reflect.field(target, name), gatherArgs(target, injector));\n\t\treturn target;\n\t}\n\t\n\tfunction gatherArgs(target:Dynamic, injector:Injector):Array<Dynamic>\n\t{\n\t\tvar values = [];\n\n\t\tfor (arg in args)\n\t\t{\n\t\t\tvar name = arg.name == null ? \"\" : arg.name;\n\t\t\tvar config = injector.getMapping(Type.resolveClass(arg.type), arg.name);\n\t\t\tvar injection = config.getResponse(injector);\n\n\t\t\t#if debug\n\t\t\tif (injection == null && !arg.opt)\n\t\t\t{\n\t\t\t\tvar targetName = Type.getClassName(Type.getClass(target));\n\t\t\t\tvar requestName = Type.getClassName(config.request);\n\t\t\t\tthrow 'Injector is missing a rule to handle injection into target $targetName. ' +\n\t\t\t\t\t'Target dependency: $requestName, method: $name, named: ' + arg.name;\n\t\t\t}\n\t\t\t#end\n\t\t\tvalues.push(injection);\n\t\t}\n\n\t\treturn values;\n\t}\n}\n\ntypedef ArgInjectionInfo = {\n\tvar opt:Bool;\n\tvar type:String;\n\t@:optional var name:String;\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject.point;\n\nimport minject.Injector;\nimport minject.point.MethodInjectionPoint;\n\nclass ConstructorInjectionPoint extends MethodInjectionPoint\n{\n\tpublic function new(args:Array<ArgInjectionInfo>)\n\t{\n\t\tsuper('new', args);\n\t}\n\t\n\toverride public function applyInjection(target:Dynamic, injector:Injector):Dynamic\n\t{\n\t\treturn Type.createInstance(target, gatherArgs(target, injector));\n\t}\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject.point;\n\nimport minject.Injector;\n\nclass NoParamsConstructorInjectionPoint implements InjectionPoint\n{\n\tpublic function new() {}\n\t\n\tpublic function applyInjection(target:Dynamic, injector:Injector):Dynamic\n\t{\n\t\treturn Type.createInstance(target, []);\n\t}\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject.point;\n\nimport minject.Injector;\n\nclass PostConstructInjectionPoint implements InjectionPoint\n{\n\tpublic var name(default, null):String;\n\tpublic var order(default, null):Int;\n\t\n\tpublic function new(name:String, ?order:Int=0)\n\t{\n\t\tthis.name = name;\n\t\tthis.order = order;\n\t}\n\t\n\tpublic function applyInjection(target:Dynamic, injector:Injector):Dynamic\n\t{\n\t\tReflect.callMethod(target, Reflect.field(target, name), []);\n\t\treturn target;\n\t}\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject.point;\n\nimport minject.Injector;\n\nclass PropertyInjectionPoint implements InjectionPoint\n{\n\tvar name:String;\n\tvar type:String;\n\tvar injectionName:String;\n\n\tpublic function new(name:String, type:String, ?injectionName:String=null)\n\t{\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.injectionName = injectionName;\n\t}\n\n\tpublic function applyInjection(target:Dynamic, injector:Injector):Dynamic\n\t{\n\t\tvar injectionConfig = injector.getMapping(Type.resolveClass(type), injectionName);\n\t\tvar injection = injectionConfig.getResponse(injector);\n\t\t#if debug\n\t\tif (injection == null)\n\t\t\tthrow 'Injector is missing a rule to handle injection into property \"$name\" ' +\n\t\t\t\t'of object \"$target\". Target dependency: \"$type\", named \"$injectionName\"';\n\t\t#end\n\t\tReflect.setProperty(target, name, injection);\n\t\treturn target;\n\t}\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject.result;\n\nimport minject.Injector;\n\nclass InjectionResult\n {\n\tpublic function new() {}\n\n\tpublic function getResponse(injector:Injector):Dynamic\n\t{\n\t\treturn null;\n\t}\n\n\tpublic function toString():String\n\t{\n\t\treturn \"\";\n\t}\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject.result;\n\nimport minject.Injector;\n\nclass InjectClassResult extends InjectionResult\n{\n\tvar responseType:Class<Dynamic>;\n\t\n\tpublic function new(responseType:Class<Dynamic>)\n\t{\n\t\tsuper();\n\t\tthis.responseType = responseType;\n\t}\n\t\n\tpublic override function getResponse(injector:Injector):Dynamic\n\t{\n\t\treturn injector.instantiate(responseType);\n\t}\n\n\toverride public function toString():String\n\t{\n\t\treturn \"class \" + Type.getClassName(responseType);\n\t}\n}\n","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject.result;\n\nimport minject.Injector;\n\nclass InjectSingletonResult extends InjectionResult\n{\n\tvar responseType:Class<Dynamic>;\n\tvar response:Dynamic;\n\t\n\tpublic function new(responseType:Class<Dynamic>)\n\t{\n\t\tsuper();\n\t\tthis.responseType = responseType;\n\t}\n\t\n\toverride public function getResponse(injector:Injector):Dynamic\n\t{\n\t\tif (response == null)\n\t\t{\n\t\t\tresponse = createResponse(injector);\n\t\t\tinjector.injectInto(response);\n\t\t}\n\n\t\treturn response;\n\t}\n\t\n\tfunction createResponse(injector:Injector):Dynamic\n\t{\n\t\treturn injector.construct(responseType);\n\t}\n\n\toverride public function toString():String\n\t{\n\t\treturn \"singleton \" + Type.getClassName(responseType);\n\t}\n}\n","/*\nCopyright (c) 2012 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage msignal;\n\nimport msignal.Signal;\n\n/**\n\tA convenience type describing any kind of slot.\n**/\ntypedef AnySlot = Slot<Dynamic, Dynamic>;\n\n/**\n\tDefines the basic properties of a listener associated with a Signal.\n**/\n#if haxe3\nclass Slot<TSignal:msignal.Signal.AnySignal, TListener>\n#else\nclass Slot<TSignal:Signal<Dynamic, TListener>, TListener>\n#end\n{\n\t/**\n\t\tThe listener associated with this slot.\n\t\tNote: for hxcpp 2.10 this requires a getter method to compile\n\t**/\n\t#if cpp\n\t#if haxe3 @:isVar #end\n\tpublic var listener(get_listener, set_listener):TListener;\n\t#else\n\t#if haxe3 @:isVar #end\n\tpublic var listener(default, set_listener):TListener;\n\t#end\n\t\n\n\t/**\n\t\tWhether this slot is automatically removed after it has been used once.\n\t**/\n\tpublic var once(default, null):Bool;\n\n\t/**\n\t\tThe priority of this slot should be given in the execution order.\n\t\tAn Signal will call higher numbers before lower ones.\n\t\tDefaults to 0.\n\t**/\n\tpublic var priority(default, null):Int;\n\n\t/**\n\t\tWhether the listener is called on execution. Defaults to true.\n\t**/\n\tpublic var enabled:Bool;\n\n\tvar signal:TSignal;\n\t\n\tfunction new(signal:TSignal, listener:TListener, ?once:Bool=false, ?priority:Int=0)\n\t{\n\t\tthis.signal = signal;\n\t\tthis.listener = listener;\n\t\tthis.once = once;\n\t\tthis.priority = priority;\n\t\tthis.enabled = true;\n\t}\n\n\t/**\n\t\tRemoves the slot from its signal.\n\t**/\n\tpublic function remove()\n\t{\n\t\tsignal.remove(listener);\n\t}\n\n\t#if cpp\n\t/**\n\t\tHxcpp 2.10 requires a getter method for a typed function property in \n\t\torder to compile\n\t**/\n\tfunction get_listener():TListener\n\t{\n\t\treturn listener;\n\t}\n\t#end\n\n\tfunction set_listener(value:TListener):TListener\n\t{\n\t\t#if debug\n\t\tif (value == null) throw \"listener cannot be null\";\n\t\t#end\n\t\treturn listener = value;\n\t}\n}\n\n/**\n\tA slot that executes a listener with no arguments.\n**/\nclass Slot0 extends Slot<Signal0, Void -> Void>\n{\n\tpublic function new(signal:Signal0, listener:Void -> Void, ?once:Bool=false, ?priority:Int=0)\n\t{\n\t\tsuper(signal, listener, once, priority);\n\t}\n\n\t/**\n\t\tExecutes a listener with no arguments.\n\t**/\n\tpublic function execute()\n\t{\n\t\tif (!enabled) return;\n\t\tif (once) remove();\n\t\tlistener();\n\t}\n}\n\n/**\n\tA slot that executes a listener with one argument.\n**/\nclass Slot1<TValue> extends Slot<Signal1<TValue>, TValue -> Void>\n{\n\t/**\n\t\tAllows the slot to inject the argument to dispatch.\n\t**/\n\tpublic var param:TValue;\n\n\tpublic function new(signal:Signal1<TValue>, listener:TValue -> Void, ?once:Bool=false, ?priority:Int=0)\n\t{\n\t\tsuper(signal, listener, once, priority);\n\t}\n\n\t/**\n\t\tExecutes a listener with one argument.\n\t\tIf <code>param</code> is not null, it overrides the value provided.\n\t**/\n\tpublic function execute(value1:TValue)\n\t{\n\t\tif (!enabled) return;\n\t\tif (once) remove();\n\t\tif (param != null) value1 = param;\n\t\tlistener(value1);\n\t}\n}\n\n/**\n\tA slot that executes a listener with two arguments.\n**/\nclass Slot2<TValue1, TValue2> extends Slot<Signal2<TValue1, TValue2>, TValue1 -> TValue2 -> Void>\n{\n\t/**\n\t\tAllows the slot to inject the first argument to dispatch.\n\t**/\n\tpublic var param1:TValue1;\n\n\t/**\n\t\tAllows the slot to inject the second argument to dispatch.\n\t**/\n\tpublic var param2:TValue2;\n\n\tpublic function new(signal:Signal2<TValue1, TValue2>, listener:TValue1 -> TValue2 -> Void, ?once:Bool=false, ?priority:Int=0)\n\t{\n\t\tsuper(signal, listener, once, priority);\n\t}\n\n\t/**\n\t\tExecutes a listener with two arguments.\n\t\tIf <code>param1</code> or <code>param2</code> is set, \n\t\tthey override the values provided.\n\t**/\n\tpublic function execute(value1:TValue1, value2:TValue2)\n\t{\n\t\tif (!enabled) return;\n\t\tif (once) remove();\n\t\t\n\t\tif (param1 != null) value1 = param1;\n\t\tif (param2 != null) value2 = param2;\n\t\t\n\t\tlistener(value1, value2);\n\t}\n}\n","/*\nCopyright (c) 2012 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage msignal;\n\nclass SlotList<TSlot:Slot<Dynamic, Dynamic>, TListener>\n{\n\t@:IgnoreCover\n\tstatic function __init__() { NIL = new SlotList<Dynamic, Dynamic>(null, null); }\n\t\n\t/**\n\t\tRepresents an empty list. Used as the list terminator.\n\t**/\n\tpublic static var NIL:SlotList<Dynamic, Dynamic>;\n\t\n\tpublic var head:TSlot;\n\tpublic var tail:SlotList<TSlot, TListener>;\n\tpublic var nonEmpty:Bool;\n\t\n\t/**\n\t\tCreates and returns a new SlotList object.\n\n\t\t<p>A user never has to create a SlotList manually. \n\t\tUse the <code>NIL</code> element to represent an empty list. \n\t\t<code>NIL.prepend(value)</code> would create a list containing \n\t\t<code>value</code></p>.\n\n\t\t@param head The first slot in the list.\n\t\t@param tail A list containing all slots except head.\n\t**/\n\tpublic function new(head:TSlot, ?tail:SlotList<TSlot, TListener>=null)\n\t{\n\t\tnonEmpty = false;\n\t\t\n\t\tif (head == null && tail == null)\n\t\t{\n\t\t\t#if debug\n\t\t\tif (NIL != null) throw \"Parameters head and tail are null. Use the NIL element instead.\";\n\t\t\t#end\n\n\t\t\t// this is the NIL element as per definition\n\t\t\tnonEmpty = false;\n\t\t}\n\t\telse if (head == null)\n\t\t{\n\t\t\t#if debug\n\t\t\tthrow \"Parameter head cannot be null.\";\n\t\t\t#end\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.head = head;\n\t\t\tthis.tail = (tail == null ? cast NIL : tail);\n\t\t\tnonEmpty = true;\n\t\t}\n\t}\n\t\n\t/**\n\t\tThe number of slots in the list.\n\t**/\n\tpublic var length(get_length, null):Int;\n\tfunction get_length():Int\n\t{\n\t\tif (!nonEmpty) return 0;\n\t\tif (tail == NIL) return 1;\n\t\t\n\t\t// We could cache the length, but it would make methods like filterNot unnecessarily complicated.\n\t\t// Instead we assume that O(n) is okay since the length property is used in rare cases.\n\t\t// We could also cache the length lazy, but that is a waste of another 8b per list node (at least).\n\t\t\n\t\tvar result = 0;\n\t\tvar p = this;\n\t\t\n\t\twhile (p.nonEmpty)\n\t\t{\n\t\t\t++result;\n\t\t\tp = p.tail;\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t\tPrepends a slot to this list.\n\t\t@param\tslot The item to be prepended.\n\t\t@return\tA list consisting of slot followed by all elements of this list.\n\t**/\n\tpublic function prepend(slot:TSlot)\n\t{\n\t\treturn new SlotList<TSlot, TListener>(slot, this);\n\t}\n\t\n\t/**\n\t\tAppends a slot to this list.\n\t\tNote: appending is O(n). Where possible, prepend which is O(1).\n\t\tIn some cases, many list items must be cloned to \n\t\tavoid changing existing lists.\n\t\t@param\tslot The item to be appended.\n\t\t@return\tA list consisting of all elements of this list followed by slot.\n\t**/\n\tpublic function append(slot:TSlot)\n\t{\n\t\tif (slot == null) return this;\n\t\tif (!nonEmpty) return new SlotList<TSlot, TListener>(slot);\n\t\t\n\t\t// Special case: just one slot currently in the list.\n\t\tif (tail == NIL) \n\t\t{\n\t\t\treturn new SlotList<TSlot, TListener>(slot).prepend(head);\n\t\t}\n\t\t\n\t\t// The list already has two or more slots.\n\t\t// We have to build a new list with cloned items because they are immutable.\n\t\tvar wholeClone = new SlotList<TSlot, TListener>(head);\n\t\tvar subClone = wholeClone;\n\t\tvar current = tail;\n\t\t\n\t\twhile (current.nonEmpty)\n\t\t{\n\t\t\tsubClone = subClone.tail = new SlotList<TSlot, TListener>(current.head);\n\t\t\tcurrent = current.tail;\n\t\t}\n\t\t\n\t\t// Append the new slot last.\n\t\tsubClone.tail = new SlotList<TSlot, TListener>(slot);\n\t\treturn wholeClone;\n\t}\t\t\n\t\n\t/**\n\t\tInsert a slot into the list in a position according to its priority.\n\t\tThe higher the priority, the closer the item will be inserted to the \n\t\tlist head.\n\t\t@param slot The item to be inserted.\n\t**/\n\tpublic function insertWithPriority(slot:TSlot)\n\t{\n\t\tif (!nonEmpty) return new SlotList<TSlot, TListener>(slot);\n\t\t\n\t\tvar priority:Int = slot.priority;\n\t\t\n\t\t// Special case: new slot has the highest priority.\n\t\tif (priority >= this.head.priority) return prepend(slot);\n\n\t\tvar wholeClone = new SlotList<TSlot, TListener>(head);\n\t\tvar subClone = wholeClone;\n\t\tvar current = tail;\n\n\t\t// Find a slot with lower priority and go in front of it.\n\t\twhile (current.nonEmpty)\n\t\t{\n\t\t\tif (priority > current.head.priority)\n\t\t\t{\n\t\t\t\tsubClone.tail = current.prepend(slot);\n\t\t\t\treturn wholeClone;\n\t\t\t}\n\t\t\t\n\t\t\tsubClone = subClone.tail = new SlotList<TSlot, TListener>(current.head);\n\t\t\tcurrent = current.tail;\n\t\t}\n\t\t\n\t\t// Slot has lowest priority.\n\t\tsubClone.tail = new SlotList<TSlot, TListener>(slot);\n\t\treturn wholeClone;\n\t}\n\t\n\t/**\n\t\tReturns the slots in this list that do not contain the supplied \n\t\tlistener. Note: assumes the listener is not repeated within the list.\n\t\t@param\tlistener The function to remove.\n\t\t@return A list consisting of all elements of this list that do not \n\t\t\t\thave listener.\n\t**/\n\tpublic function filterNot(listener:TListener)\n\t{\n\t\tif (!nonEmpty || listener == null) return this;\n\t\t\n\t\tif (Reflect.compareMethods(head.listener, listener)) return tail;\n\t\t\n\t\t// The first item wasn't a match so the filtered list will contain it.\n\t\tvar wholeClone = new SlotList<TSlot, TListener>(head);\n\t\tvar subClone = wholeClone;\n\t\tvar current = tail;\n\t\t\n\t\twhile (current.nonEmpty)\n\t\t{\n\t\t\tif (Reflect.compareMethods(current.head.listener, listener))\n\t\t\t{\n\t\t\t\t// Splice out the current head.\n\t\t\t\tsubClone.tail = current.tail;\n\t\t\t\treturn wholeClone;\n\t\t\t}\n\t\t\t\n\t\t\tsubClone = subClone.tail = new SlotList<TSlot, TListener>(current.head);\n\t\t\tcurrent = current.tail;\n\t\t}\n\t\t\n\t\t// The listener was not found so this list is unchanged.\n\t\treturn this;\n\t}\n\t\n\t/**\n\t\tDetermines whether the supplied listener Function is contained \n\t\twithin this list\n\t**/\n\tpublic function contains(listener:TListener):Bool\n\t{\n\t\tif (!nonEmpty) return false;\n\n\t\tvar p = this;\n\t\twhile (p.nonEmpty)\n\t\t{\n\t\t\tif (Reflect.compareMethods(p.head.listener, listener)) return true;\n\t\t\tp = p.tail;\n\t\t}\n\n\t\treturn false;\n\t}\n\t\n\t/**\n\t\tRetrieves the Slot associated with a supplied listener within the SlotList.\n\t\t@param   listener The Function being searched for\n\t\t@return  The ISlot in this list associated with the listener parameter \n\t\t\t\t through the ISlot.listener property. Returns null if no such \n\t\t\t\t ISlot instance exists or the list is empty.  \n\t**/\n\tpublic function find(listener:TListener):TSlot\n\t{\n\t\tif (!nonEmpty) return null;\n\t\t\n\t\tvar p = this;\n\t\twhile (p.nonEmpty)\n\t\t{\n\t\t\tif (Reflect.compareMethods(p.head.listener, listener)) return p.head;\n\t\t\tp = p.tail;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n}\n","package tink.core;\r\n\r\nimport tink.core.Outcome;\r\n\r\ntypedef Pos = \r\n\t#if macro\r\n\t\thaxe.macro.Expr.Position;\r\n\t#else\r\n\t\thaxe.PosInfos;\r\n\t#end\r\n\r\n//TODO: there's huge overlap with haxe.macro.Error\r\ntypedef Error = TypedError<Dynamic>;\r\n\r\n@:enum abstract ErrorCode(Int) from Int to Int {\r\n\tvar BadRequest = 400;\r\n\tvar Unauthorized = 401;\r\n\tvar PaymentRequired = 402;\r\n\tvar Forbidden = 403;\r\n\tvar NotFound = 404;\r\n\tvar MethodNotAllowed = 405;\r\n\tvar Gone = 410;\r\n\tvar NotAcceptable = 406;\r\n\tvar Timeout = 408;\r\n\tvar Conflict = 409;\r\n\tvar OutOfRange = 416;\r\n\tvar ExpectationFailed = 417;\r\n\tvar I_am_a_Teapot = 418;\r\n\tvar AuthenticationTimeout = 419;\r\n\tvar UnprocessableEntity = 422;\r\n\r\n\tvar InternalError = 500;\r\n\tvar NotImplemented = 501;\r\n\tvar ServiceUnavailable = 503;\r\n\tvar InsufficientStorage = 507;\r\n\tvar BandwidthLimitExceeded = 509;\r\n\r\n}\r\n\r\nclass TypedError<T> {\r\n\tpublic var message(default, null):String;//It might make sense for the message to be lazy\r\n\tpublic var code(default, null):ErrorCode;\r\n\tpublic var data(default, null):T;\r\n\tpublic var pos(default, null):Null<Pos>;\r\n\t\r\n\tpublic function new(?code:ErrorCode = InternalError, message, ?pos) {\r\n\t\tthis.code = code;\r\n\t\tthis.message = message;\r\n\t\tthis.pos = pos;\r\n\t}\r\n\tfunction printPos()\r\n\t\treturn\r\n\t\t\t#if macro\r\n\t\t\t\tStd.string(pos);\r\n\t\t\t#else\r\n\t\t\t\tpos.className+'.'+pos.methodName+':'+pos.lineNumber;\r\n\t\t\t#end\r\n\t\t\t\r\n\t@:keep public function toString() {\r\n\t\tvar ret = 'Error#$code: $message';\r\n\t\tif (pos != null)\r\n\t\t\tret += \" \"+printPos();\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t@:keep public function throwSelf():Dynamic\r\n\t\treturn\r\n\t\t\t#if macro\r\n\t\t\t\t#if tink_macro\r\n\t\t\t\t\ttink.macro.Positions.error(pos, message);\r\n\t\t\t\t#else\r\n\t\t\t\t\thaxe.macro.Context.error(message, if (pos == null) haxe.macro.Context.currentPos() else pos);\r\n\t\t\t\t#end\r\n\t\t\t#else\r\n\t\t\t\trethrow(this);\r\n\t\t\t#end\r\n\t\t\r\n\tstatic public function withData(?code:ErrorCode, message:String, data:Dynamic, ?pos:Pos):Error {\r\n\t\treturn typed(code, message, data, pos);\r\n\t}\r\n\t\r\n\tstatic public function typed<A>(?code:ErrorCode, message:String, data:A, ?pos:Pos):TypedError<A> {\r\n\t\tvar ret = new TypedError(code, message, pos);\r\n\t\tret.data = data;\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tstatic public function catchExceptions<A>(f:Void->A, ?report:Dynamic->Error)\r\n\t\treturn\r\n\t\t\ttry \r\n\t\t\t\tSuccess(f())\r\n\t\t\tcatch (e:Error)\r\n\t\t\t\tFailure(e)\r\n\t\t\tcatch (e:Dynamic)\r\n\t\t\t\tFailure(\r\n\t\t\t\t\tif (report == null)\r\n\t\t\t\t\t\tError.withData('Unexpected Error', e)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treport(e)\r\n\t\t\t\t);\t\t\r\n\t\r\n\tstatic public function reporter(?code:ErrorCode, message:String, ?pos:Pos):Dynamic->Error \r\n\t\treturn \r\n\t\t\tfunction (e:Dynamic) return Error.withData(code, message, e, pos);\r\n\t\t\t\r\n\tstatic public inline function rethrow(any:Dynamic):Dynamic {\r\n\t\t#if neko\r\n\t\t\tneko.Lib.rethrow(any);\r\n\t\t#elseif php\r\n\t\t\tphp.Lib.rethrow(any);\r\n\t\t#elseif cpp\r\n\t\t\tcpp.Lib.rethrow(any);\r\n\t\t#else\r\n\t\t\tthrow any;\r\n\t\t#end\r\n\t\treturn any;\r\n\t}\r\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage;\n\n// Can't enable @:coreApi because some fields are now inline getters\n// @:coreApi\n@:keepInit\nextern class Math\n{\n\tstatic var PI(default,null) : Float;\n\n\tstatic var NEGATIVE_INFINITY(get, null) : Float;\n\tprivate static inline function get_NEGATIVE_INFINITY () : Float {\n\t\treturn -(untyped __js__(\"Infinity\"));\n\t}\n\n\tstatic var POSITIVE_INFINITY(get,null) : Float;\n\tprivate static inline function get_POSITIVE_INFINITY () : Float {\n\t\treturn (untyped __js__(\"Infinity\"));\n\t}\n\n\tstatic var NaN(get, null) : Float;\n\tprivate static inline function get_NaN () : Float {\n\t\treturn (untyped __js__(\"NaN\"));\n\t}\n\n\tstatic function abs(v:Float):Float;\n\tstatic function acos(v:Float):Float;\n\tstatic function asin(v:Float):Float;\n\tstatic function atan(v:Float):Float;\n\tstatic function atan2(y:Float, x:Float):Float;\n\tstatic function ceil(v:Float):Int;\n\tstatic function cos(v:Float):Float;\n\tstatic function exp(v:Float):Float;\n\tstatic function floor(v:Float):Int;\n\tstatic function log(v:Float):Float;\n\tstatic function max(a:Float, b:Float):Float;\n\tstatic function min(a:Float, b:Float):Float;\n\tstatic function pow(v:Float, exp:Float):Float;\n\tstatic function random() : Float;\n\tstatic function round(v:Float):Int;\n\tstatic function sin(v:Float):Float;\n\tstatic function sqrt(v:Float):Float;\n\tstatic function tan(v:Float):Float;\n\n\tstatic inline function ffloor( v : Float ) : Float {\n\t\treturn floor(v);\n\t}\n\n\tstatic inline function fceil( v : Float ) : Float {\n\t\treturn ceil(v);\n\t}\n\n\tstatic inline function fround( v : Float ) : Float {\n\t\treturn round(v);\n\t}\n\n\tstatic inline function isFinite( f : Float ) : Bool {\n\t\treturn (untyped __js__(\"isFinite\"))(f);\n\t}\n\n\tstatic inline function isNaN( f : Float ) : Bool {\n\t\treturn (untyped __js__(\"isNaN\"))(f);\n\t}\n\n\tstatic function __init__() : Void {\n\t\tuntyped __feature__(\"Type.resolveClass\", $hxClasses[\"Math\"] = Math);\n\t}\n}\n","/****\n* Copyright (c) 2013 Jason O'Neil\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*\n****/\n\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Format;\nimport haxe.Json;\n#if yaml\nimport yaml.Yaml;\nimport yaml.Parser;\nimport yaml.Renderer;\nimport yaml.util.ObjectMap;\n#end\nusing StringTools;\nusing Lambda;\n\nclass CompileTime\n{\n    /** Inserts a date object of the date and time that this was compiled */\n    macro public static function buildDate():ExprOf<Date> {\n        var date = Date.now();\n        var year = toExpr(date.getFullYear());\n        var month = toExpr(date.getMonth());\n        var day = toExpr(date.getDate());\n        var hours = toExpr(date.getHours());\n        var mins = toExpr(date.getMinutes());\n        var secs = toExpr(date.getSeconds());\n        return macro new Date($year, $month, $day, $hours, $mins, $secs);\n    }\n\n    /** Returns a string of the date and time that this was compiled */\n    macro public static function buildDateString():ExprOf<String> {\n        return toExpr(Date.now().toString());\n    }\n\n    /** Reads a file at compile time, and inserts the contents into your code as a string.  The file path is resolved using `Context.resolvePath`, so it will search all your class paths */\n    macro public static function readFile(path:String):ExprOf<String> {\n        return toExpr(loadFileAsString(path));\n    }\n\n    /** Reads a file at compile time, and inserts the contents into your code as an interpolated string, similar to using 'single $quotes'.  */\n    macro public static function interpolateFile(path:String):ExprOf<String> {\n        return Format.format( toExpr(loadFileAsString(path)) );\n    }\n\n    /** Same as readFile, but checks that the file is valid Json */\n    macro public static function readJsonFile(path:String):ExprOf<String> {\n        var content = loadFileAsString(path);\n        try Json.parse(content) catch (e:Dynamic) {\n            haxe.macro.Context.error('Json from $path failed to validate: $e', Context.currentPos());\n        }\n        return toExpr(content);\n    }\n\n    /** Same as readFile, but checks that the file is valid Json */\n    macro public static function parseJsonFile(path:String):ExprOf<{}> {\n        var content = loadFileAsString(path);\n        var obj = try Json.parse(content) catch (e:Dynamic) {\n            haxe.macro.Context.error('Json from $path failed to validate: $e', Context.currentPos());\n        }\n        return toExpr(obj);\n    }\n\n    #if yaml\n    macro public static function parseYamlFile(path:String) {\n      var content = loadFileAsString(path);\n      var data = Yaml.parse(content, Parser.options().useObjects());\n      var s = haxe.Json.stringify(data);\n      var json = haxe.Json.parse(s);\n      return toExpr(json);\n    }\n    #end\n\n\n    /** Same as readFile, but checks that the file is valid Xml */\n    macro public static function readXmlFile(path:String):ExprOf<String> {\n        var content = loadFileAsString(path);\n        try Xml.parse(content) catch (e:Dynamic) {\n            haxe.macro.Context.error('Xml from $path failed to validate: $e', Context.currentPos());\n        }\n        return toExpr(content);\n    }\n\n    #if markdown\n        /** Same as readFile, but checks that the file is valid Xml */\n        macro public static function readMarkdownFile(path:String):ExprOf<String> {\n            var content = loadFileAsString(path);\n            try {\n                content = Markdown.markdownToHtml( content );\n                Xml.parse(content);\n            } catch (e:Dynamic) {\n                haxe.macro.Context.error('Markdown from $path did not produce valid XML: $e', Context.currentPos());\n            }\n            return toExpr(content);\n        }\n    #end\n\n    /** Import a package at compile time.  Is a simple mapping to haxe.macro.Compiler.include(), but means you don't have to wrap your code in conditionals. */\n    macro public static function importPackage(path:String, ?recursive:Bool = true, ?ignore : Array<String>, ?classPaths : Array<String>) {\n        haxe.macro.Compiler.include(path, recursive, ignore, classPaths);\n        return toExpr(0);\n    }\n\n    /** Returns an Array of Classes.  By default it will return all classes, but you can also search for classes in a particular package,\n    classes that extend a particular type, and you can choose whether to look for classes recursively or not. */\n    macro public static function getAllClasses<T>(?inPackage:String, ?includeChildPackages:Bool = true, ?extendsBaseClass:ExprOf<Class<T>>):ExprOf<Iterable<Class<T>>> {\n        var p = Context.currentPos();\n        var baseClass:ClassType = getClassTypeFromExpr(extendsBaseClass);\n        var baseClassName:String = (baseClass == null) ? \"\" : baseClass.pack.join('.') + '.' + baseClass.name;\n        var listIDExpr = toExpr(inPackage + \",\" + includeChildPackages + \",\" + baseClassName);\n        Context.onGenerate(checkForMatchingClasses.bind(inPackage, includeChildPackages, baseClass, listIDExpr, p));\n        if (extendsBaseClass!=null)\n            return macro CompileTimeClassList.getTyped($listIDExpr, $extendsBaseClass);\n        else\n            return macro CompileTimeClassList.get($listIDExpr);\n    }\n\n    #if macro\n        static function toExpr(v:Dynamic) {\n            return Context.makeExpr(v, Context.currentPos());\n        }\n\n        static function loadFileAsString(path:String) {\n            try {\n                var p = Context.resolvePath(path);\n                Context.registerModuleDependency(Context.getLocalModule(),p);\n                return sys.io.File.getContent(p);\n            }\n            catch(e:Dynamic) {\n                return haxe.macro.Context.error('Failed to load file $path: $e', Context.currentPos());\n            }\n        }\n\n        static function isSameClass(a:ClassType, b:ClassType):Bool {\n            return (\n                a.pack.join(\".\") == b.pack.join(\".\")\n                && a.name == b.name\n            );\n        }\n\n        static function implementsInterface(cls:ClassType, interfaceToMatch:ClassType):Bool {\n            while (cls!=null) {\n                for ( i in cls.interfaces ) {\n                    if (isSameClass(i.t.get(), interfaceToMatch)) {\n                        return true;\n                    }\n                }\n                if (cls.superClass!=null) {\n                    cls = cls.superClass.t.get();\n                }\n                else cls = null;\n            }\n            return false;\n        }\n\n        static function isSubClassOfBaseClass(subClass:ClassType, baseClass:ClassType):Bool {\n            var cls = subClass;\n            while (cls.superClass != null)\n            {\n                cls = cls.superClass.t.get();\n                if (isSameClass(baseClass, cls)) { return true; }\n            }\n            return false;\n        }\n\n        static function getClassTypeFromExpr(e:Expr):ClassType {\n            var ct:ClassType = null;\n            var fullClassName = null;\n            var parts = new Array<String>();\n            var nextSection = e.expr;\n            while (nextSection != null) {\n                // Break the loop unless we explicitly encounter a next section...\n                var s = nextSection;\n                nextSection = null;\n\n                switch (s) {\n                    // Might be a direct class name, no packages\n                    case EConst(c):\n                        switch (c) {\n                            case CIdent(s):\n                                if (s != \"null\") parts.unshift(s);\n                            default:\n                        }\n                    // Might be a fully qualified package name\n                    // { expr => EField({ expr => EField({ expr => EConst(CIdent(sys)), pos => #pos(src/server/Server.hx:35: characters 53-56) },db), pos => #pos(src/server/Server.hx:35: characters 53-59) },Object), pos => #pos(src/server/Server.hx:35: characters 53-66) }\n                    case EField(e, field):\n                        parts.unshift(field);\n                        nextSection = e.expr;\n                    default:\n                }\n            }\n            fullClassName = parts.join(\".\");\n            if (fullClassName != \"\") {\n                switch (Context.getType(fullClassName)) {\n                    case TInst(classType, _):\n                        ct = classType.get();\n                    default:\n                        throw \"Currently CompileTime.getAllClasses() can only search by package name or base class, not interface, typedef etc.\";\n                }\n            }\n            return ct;\n        }\n\n        static function checkForMatchingClasses(?inPackage:String, ?includeChildPackages:Bool = true, ?baseClass:ClassType, listIDExpr:Expr, p:Position, arr:Array<haxe.macro.Type>) {\n            var classesFound:Array<String> = [];\n            for (type in arr) {\n                switch (type) {\n                    // We only care for Classes\n                    case TInst(t, _):\n                        var include = true;\n\n                        if (t.get().isInterface)\n                            include = false;\n\n                        // Check if it belongs to a certain package or subpackage\n                        if (inPackage != null) {\n                            if (includeChildPackages) {\n                                if (t.toString().startsWith(inPackage) == false)\n                                    include = false;\n                            }\n                            else {\n                                var re = new EReg(\"^\" + inPackage + \"\\\\.([A-Z][a-zA-Z0-9]*)$\", \"\");\n                                if (re.match(t.toString()) == false)\n                                    include = false;\n                            }\n                        }\n\n                        // Check if it is a subclass of a certain type\n                        if (baseClass != null) {\n                            if (baseClass.isInterface) {\n                                if (implementsInterface(t.get(), baseClass) == false)\n                                    include = false;\n                            }\n                            else {\n                                if (isSubClassOfBaseClass(t.get(), baseClass) == false)\n                                    include = false;\n                            }\n                        }\n\n                        if (include)\n                            classesFound.push(t.toString());\n                    default:\n                }\n            }\n\n            // Create a list of all the qualified class names\n            var classNames = classesFound.map(function (c) { return c.toString(); });\n            var classNamesExpr = toExpr(classNames.join(\",\"));\n\n            // Get the CompileTimeClassList class\n            var ct:ClassType = null;\n            switch (Context.getType(\"CompileTimeClassList\")) {\n                case TInst(classType, _):\n                    ct = classType.get();\n                default:\n            }\n\n            // If the @classLists metadata already exists, get a copy of it and remove it\n            // (We'll re-add it in a minute)\n            var classListsMetaArray:Array<Expr>;\n            if (ct.meta.has('classLists')) {\n                classListsMetaArray = ct.meta.get().filter(function (i) { return i.name == \"classLists\"; })[0].params;\n                ct.meta.remove('classLists');\n            }\n            else {\n                classListsMetaArray = [];\n            }\n\n            // Add the class names to CompileTimeClassList as metadata\n            var itemAsArray = macro [$listIDExpr, $classNamesExpr];\n            classListsMetaArray.push(itemAsArray);\n            ct.meta.add('classLists', classListsMetaArray, Context.currentPos());\n\n            return;\n        }\n    #end\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tThis type unifies with any function type.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\n@:callable\nabstract Function(Dynamic) { }\n\n/**\n\tThis type unifies with an enum instance if all constructors of the enum\n\trequire no arguments.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\nabstract FlatEnum(Dynamic) { }\n\ninterface IMap<K,V> {\n\tpublic function get(k:K):Null<V>;\n\tpublic function set(k:K, v:V):Void;\n\tpublic function exists(k:K):Bool;\n\tpublic function remove(k:K):Bool;\n\tpublic function keys():Iterator<K>;\n\tpublic function iterator():Iterator<V>;\n\tpublic function toString():String;\n}","/*\nCopyright (c) 2012-2014 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage minject.point;\n\nimport minject.Injector;\n\ninterface InjectionPoint\n{\n\tfunction applyInjection(target:Dynamic, injector:Injector):Dynamic;\n}\n"],
"names":[],
"mappings":"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"
}